## (2025-08-16) 세션 & 토큰 실시간 기능 업데이트
- GameSession 테이블(Alembic 20250816_add_game_sessions_table) 도입: int PK + external_session_id(UUID) unique, 인덱스(user_id+status, user_id+game_type, start_time, created_at)
- /api/games/session/start,end 영속화: 활성 중복 409, 종료 시 total_rounds/total_bet/total_win 기록
- /api/games/session/active 추가, GameHistory SESSION_START/END 로깅
- WebSocket: game_session 이벤트( start/end ) 확장 + token_update 이벤트(TokenService add/deduct hook)
- 향후 확장 예정: token_update에 history_id, balance_coin/gem 세분화, 세션 라운드 자동 누적 및 ROI

### 검증 (계획/수행)
- [ ] alembic upgrade head 후 game_sessions 존재 및 인덱스 확인(ix_game_sessions_*)
- [ ] pytest: 세션 시작/중복/종료/active/token_update 이벤트 수신 케이스 통과
- [ ] WebSocket 수동 스모크: start→end 흐름 메시지 2종 + 토큰 변경 시 token_update

### 다음 단계
1. 테스트 구현 및 실행 결과 반영
2. token_update payload 구조 확장(history_id, gem/coin 구분)
3. 세션 내 베팅/승리 자동 누적과 세션 KPI(ROI, 평균 라운드 길이) 엔드포인트 설계

## 체크리스트 검증 방법
각 항목의 체크 방법은 다음과 같습니다:
- ✅ 완료: 기능이 구현되고, 테스트되었으며, 문서화됨
- ⚠️ 테스트 필요: 구현은 완료되었으나 테스트 및 문서화/ 개선이 필요함. 부분완료
- ❌ 미완료: 아직 시작되지 않음

## 검증 체크리스트
- [✅] 상품 카탈로그 관리: SKU/이름/가격/젬/할인/필요 등급 노출
- [✅] 격 정책 및 할인 시스템: 🏷️ 할인율 및 ⏱️ 종료시각에 따라 🧮 총액 계산
- [✅] 구매 전 검증(자격): VIP 전용 상품에 일반 사용자가 접근 시 403
- [✅] 결제 게이트웨이 연동: authorize 실패/성공, capture 실패/성공 처리
- [✅] 보상 지급: cyber_token_balance 증액
- [✅] 거래 로그: UserAction(action_type=SHOP_BUY) 및 charge_id 기록

### 추가 체크리스트 — 결제/영속/문서/관측/테스트 (2025-08-15)
- [✅] 멱등성/결제 안정성
  - [✅] 구매 API idempotency_key 지원(중복 결제 방지, 재시도 안전)
  - [✅] Redis 키 TTL 설계 및 원자적 재고 감소(try_reserve→finalize/timeout release)
- [✅] 이력/영속화
  - [✅] DB 스키마 정식화(Alembic): 패키지/재고/구매/프로모 사용 로그 테이블
  - [✅] 관리자 감사 로그(누가/언제/무엇을) 표준화 (+ 인덱스 ix_admin_audit_action_created)
- [✅] 계약/문서화
  - [✅] Admin/Shop 샘플 요청/응답 예시 추가
  - [✅] reason 코드 표준 공개(OUT_OF_STOCK, DISABLED, WINDOW_CLOSED, USER_LIMIT, PROMO_EXHAUSTED 등)
  - [✅] 프런트 연동 가이드(프로모 입력, 비활성/기간외/재고없음 UI 처리 기준)
- [ ] 관측성/분석
  - [ ] Kafka 구매 이벤트 → ClickHouse 적재 파이프라인 스모크 테스트
  -  1 재고/구매율/프로모 사용률 대시보드 초안(Grafana/Metabase)
- [✅] 테스트 보강
  - [✅] 동시 구매 경합 시나리오
  - [✅] 예약 취소(예약→타임아웃) 케이스
  - [⚠️] 프로모 소진 경계값


### 진행상황 체크리스트
- [✅] **Alembic 마이그레이션 충돌 해결** (테이블 중복, 컬럼 충돌 등)
- [✅] 기존 테이블 중복(OperationalError) 해결
- [✅] 마이그레이션 히스토리 정리 및 초기화
- [✅] 스키마 정합성 검증

- [✅] **롤백/다운그레이드 정상 동작** (운영/테스트 환경 모두)
- [✅] PostgreSQL 환경에서 롤백 테스트 (downgrade -1 → upgrade 왕복 성공)
- [✅] SQLite 제약조건 우회 방안 (일부 롤백 불가, 테이블 recreate/백업 권장)
- [✅] 안전한 롤백 전략 문서화 (초안 추가 아래 참고)

- [✅] **마이그레이션 의존성/순서 정합성 확보**
- [✅] 마이그레이션 체인 검증 (alembic current/head 단일, history 점검)
- [✅] FK/제약조건 순서 정리 (일부 점검 필요)
- [✅] 의존성 그래프 문서화 (초안 추가 아래 참고)

- [✅] **운영/테스트 DB 환경 분리** 및 .env/컨테이너 분리
- [✅] .env.test 생성 (테스트 DB/시크릿 분리)
- [✅] docker-compose.test.yml로 테스트 DB 격리 기동 검증
- [✅] CI에서 .env.test 사용하여 alembic+pytest 실행 (GitHub Actions 추가)

- [✅] **Kafka/Zookeeper 컨테이너 정상 기동** 
- (docker-compose, 네트워크, 포트, 네임 충돌 해결)
- [⚠️] **FastAPI Kafka 연동** (aiokafka/kafka-python 연결 설정, 
- 실제 Producer/Consumer 연동) — Producer OK, Consumer pending
- 소비자 초기화 개선: 파티션 assignment 대기 후 seek-to-beginning 적용 메시지 유실 방지), 
  pytest 실행 시 thread 기반 소비자 강제 및 고유 consumer group 사용
- 프로듀서 전송 확인: 동기 전송(future.get) 및 메타데이터 로그(topic/partition/offset) 출력 추가
- [✅] **Kafka 연동 자동화 테스트/문서화** (pytest 통합 테스트, 운영/테스트 환경 분리)

### 작업 체크리스트
- [✅] backend/requirements.txt에 aiokafka(or kafka-python) 추가 (kafka-python/aiokafka 이미 포함)
- [✅] 설정: app.core.config.settings에 Kafka 설정 키 정의 (KAFKA_BOOTSTRAP_SERVERS, KAFKA_ENABLED)
- [✅] 서비스: KafkaProducer/KafkaConsumer 래퍼 모듈 1개만 사용 (app/kafka_client.py 재사용)
- [✅] 엔드포인트: /api/kafka/produce, /api/kafka/health 추가 (app/routers/kafka_api.py)
- [✅] pytest 통합 테스트: 브로커 없으면 skip (app/tests/test_kafka_integration.py)
- [✅] 라운드트립 테스트 추가(app/tests/test_kafka_roundtrip.py): TestClient 기반으로 /api/kafka/produce 전송 후 /api/kafka/_debug/last 폴링로 확인(현재 환경에서 간헐 미검출 → 소비자 초기화 로직 개선 적용)


### 1. 백엔드 (Backend)
#### 핵심 인프라
- [✅] FastAPI 프로젝트 초기화 및 구조화 (routers, services, repositories, schemas/models)
- 체크 방법: 컨테이너에서 서버 기동 시 /docs 엔드포인트 정상 노출 확인
- 검증 기준: 프로젝트 구조가 Clean Architecture 원칙을 따름
- 체크 대상: (검증 결과)
- [✅] 프로젝트 디렉토리 구조 (routers/, services/, repositories/, schemas/, models/ 등) 존재
- [✅] main.py 엔트리 포인트 존재 및 라우터 포함/미들웨어 설정
- [✅] config.py (app/core/config.py)와 docker-compose(.env.test 포함)로 환경 설정 일원화
- [✅] middleware 설정 (SimpleLoggingMiddleware, CORS) 적용, 커스텀 에러 핸들러는 보류
- [✅] 의존성 주입 설정 (get_db 등 DI 패턴 사용 가능; 라우터에서 Depends 활용)
- [✅] API 문서화 설정 (Swagger /docs, /redoc 경로 활성)
- [✅] PostgreSQL 연동 및 SQLAlchemy ORM 설정 (구조/연결/세션/엔진 정상)
- 체크 방법: alembic upgrade head 실행 및 DB 연결 테스트
- 검증 기준: 모델 CRUD 작업이 오류 없이 수행됨
- 체크 대상:
- [✅] database.py 설정 파일 (엔진/세션, Postgres/SQLite fallback)
- [✅] SQLAlchemy Base 및 SessionLocal 관리 (app.database.Base)
- [✅] 환경 변수: POSTGRES_* / DATABASE_URL 지원 (compose.test에서 주입)
- [✅] 연결 옵션/echo 설정 및 연결 성공 로그 출력
- [✅] 트랜잭션 스코프(get_db DI) 제공
- [✅] 기본 모델 클래스는 각 모델 모듈에서 Base 상속으로 일관 사용
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨


- [✅] Alembic 마이그레이션 구성 및 적용 (구성/경로/스크립트/메타데이터연동정상)
- 체크 방법: alembic revision --autogenerate 명령으로 새 마이그레이션 생성
- 검증 기준: 테이블 스키마 변경이 올바르게 적용됨
- 체크 대상:
- [✅] alembic.ini 설정 파일 존재
- [✅] migrations(versions/) 구성 및 리비전 다수 존재, 단일 head 유지
- [✅] env.py: app.models.Base 메타데이터 사용, POSTGRES_* 환경에서 URL구성
- [✅] 초기/후속 마이그레이션 스크립트 존재(merge 포함) 및 순서 정합
- [✅] 롤백 지원: Postgres에서 downgrade/upgrade 왕복 검증 완료(로그참조), 
  - SQLite 제한은 문서화
- [✅] 의존성 순서 점검 및 merge로 단일 head 유지(f79d04ea1016 이후 head=20250810_align_users)
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨
  - [참고] SQLite 환경에서 롤백(downgrade) 불가(OperationalError: NOT NULL 컬럼 추가 불가) → 개발 환경에서는 recreate/백업 전략 병행 필요
  - 마이그레이션 체인/의존성 순서는 정상이나, 다운그레이드 시 DBMS별 제약(특히 SQLite)로 일부 롤백 불가
  - [✅] 운영 DB(PostgreSQL) 실전 검증 완료: 마이그레이션/롤백/의존성 순서 정상 동작 확인(테스트 스택 기준)


### DB 인프라 개선/정합성 체크리스트

- ✅ Alembic 마이그레이션 충돌 해결 (테이블 중복, 컬럼 충돌 등)
- ✅ 롤백/다운그레이드 정상 동작 (운영/테스트 환경 모두)
- ✅ 마이그레이션 의존성/순서 정합성 확보
- ✅ 운영/테스트 DB 환경 분리 및 .env/컨테이너 분리
- ❌ 주요 테이블/인덱스/제약조건 설계 확정
- ✅ 트랜잭션/원자성/정합성 테스트
- ✅ 데이터 정합성 검증(샘플 데이터, CRUD, FK 등) — 기본 CRUD/FK 스모크 통과
- ⚠️ 백업/복구 전략 수립 및 테스트
- 메모: 컨테이너 내부 덤프/복구 스니펫
- 백업: `docker exec cc_postgres pg_dump -U cc_user -d cc_webapp > backup_cc_webapp_$(Get-Date -Format yyyyMMddHHmmss).sql`
- 복구(주의: 데이터 삭제): `docker exec -i cc_postgres psql -U cc_user -d cc_webapp < backup.sql`
- ✅ 마이그레이션/정합성 자동화 테스트 스크립트 작성 — CI Alembic history + downgrade(-1)/upgrade head 추가
- ✅ 개선/이슈/해결내역 문서화
- ✅ Kafka 연동 (이벤트/실시간 데이터 처리) — 최소 연결/라운드트립(피크) 스모크 완료
- 체크 방법: Producer/Consumer 테스트, 메시지 발행/구독 확인
- 검증 기준: 메시지 손실 없이 전달되는지 확인
- 체크 대상:
- ✅ Kafka 연결 설정
- ✅ 토픽 정의 및 생성 — auto-create + CI KAFKA_TEST_TOPIC=cc_test_ci
- ✅ Producer 구현 (사용자 행동, 보상 이벤트 등)
- ✅ Consumer 그룹 설정 — 고유 consumer group/pytest 격리
- ✅ 오류 처리 및 재시도 메커니즘
- ❌ 스키마 레지스트리 연동 (필요시)

### 다음 단계(2025-08-11)
- [✅] app/tests/test_invite_validate_api.py 작성 및 통과: 유효/만료/사용초과/미존재 코드 케이스 + 응답 포맷 검증
- [✅] InviteCode 모델↔DB 스키마 정합성 정리: expires_at/max_uses/used_count/created_by 필드 통일, Alembic 보강
- [✅] 라우터 최소 등급 의존성(require_min_rank) 구현 및 데모 엔드포인트 적용(+403/200 테스트)
- [⚠️] 백업/복구 스크립트(ps1) 및 간단 Runbook 섹션 추가

- [❌] JWT 인증 및 권한 관리 (초대코드/닉네임 기반, VIP/등급별 접근제어)
  - 체크 방법: 토큰 발급/검증 테스트, 보호된 엔드포인트 접근 시도
  - 검증 기준: 인증 헤더 없이 접근 시 401, 권한 없는 경우 403 반환
  - 체크 대상:
- [✅] JWT 인코딩/디코딩 기능 (AuthService.create_access_token/verify_token 구현, 테스트 통과)
- [✅] 토큰 발급 엔드포인트 (/api/auth/signup, /api/auth/login, /api/auth/admin/login)
- [✅] 만료 시간 설정 (JWT_EXPIRE_MINUTES 환경변수, 기본 30분)
- [✅] 토큰 리프레시 메커니즘 (/api/auth/refresh, Authorization Bearer 혹은 body.refresh_token 허용)
- [✅] 역할 기반 접근 제어 (RBAC) — require_min_rank 의존성 및 /api/rbac/premium, /api/rbac/vip 데모로 검증
- [✅] VIP/PREMIUM/STANDARD 등급별 권한 — 서비스의 check_rank_access 적용 및 테스트 보강 완료

### 다음 단계(추가 — 2025-08-15)
- [✅] Redis 키 전략/멱등키 설계 반영(구매 API/서비스 레벨)
- [✅] DB 스키마 도출 및 Alembic 마이그레이션 초안 작성(테이블/인덱스/제약) *(기존 20250813/20250815 리비전 집합 활용 – 신규 초안 불필요 판단)*
- [✅] 문서 보강: Admin/Shop 예시 페이로드/응답 및 reason 코드 표 추가, FE 연동 가이드 업데이트


- [❌] 테스트 코드(Pytest) 및 에러/로깅/문서화
  - 체크 방법: pytest -v 실행, 코드 커버리지 확인
  - 검증 기준: 핵심 기능 80% 이상 테스트 커버리지, 예외 처리 문서화
  - 체크 대상:
- [❌] 단위 테스트 (서비스, 리포지토리)
- [❌] 통합 테스트 (API 엔드포인트)
- [❌] 로깅 설정 (구조화된 로그)
- [❌] 에러 핸들링 미들웨어
- [❌] 사용자 정의 예외 클래스
- [❌] API 문서화 (OpenAPI/Swagger)


### 사용자 여정 1: 진입 및 등록
- [✅] 초대코드 유효성 검증 API (/api/invite/validate)
  - 체크 방법: 유효/만료/존재하지 않는 코드로 API 호출 
  - 검증 기준: 적절한 HTTP 상태 코드와 응답 메시지 반환 
  - 체크 대상: 코드는 고정값 5858 ✅ 테스트 완료 - 무한재사용 구현됨
- [✅] 유효성 검사 로직 — 다양한 케이스(유효/만료/사용초과/미존재) 테스트로 검증
- [✅] 만료 시간 검사 — expires_at 기준 비교로 동작 확인
- [✅] 사용 횟수 제한 검사 — None=무제한, 정수=남은횟수 계산 로직 검증
- [⚠️] 코드 보안 (예측 불가능성) — DEFAULT_INVITE_CODE 난수화 권장(운영 시 고정값 금지)
- [✅] 응답 포맷 (is_valid/error_message/code/expires_at/remaining_uses) — OpenAPI와 일치 검증
- 메모(2025-08-11): pytest.ini가 app/tests만 인식하므로 backend/tests 하 초대코드 테스트는 무시됨. app/tests/test_invite_validate.py 추가 필요. 또한 InviteCode 모델에 expires_at/max_uses/used_count 필드가 누락된 구현이 존재(simple_auth_models 등); 실제 DB/마이그레이션과 정합성 재검증 필요.

- [✅] 회원가입 API (POST /api/auth/signup)
  - 체크 방법: 유효한 초대코드와 닉네임으로 회원가입 시도
  - 검증 기준: 성공 시 사용자 생성 및 JWT 토큰 발급, 중복/오류 시 적절한 오류 응답 됨
- 체크 대상:
- [✅] 필수 필드 유효성 검사 (site_id, nickname, phone_number?, password, invite_code)
- [✅] 닉네임/아이디 중복 검사
- [✅] 초대코드 사용 처리 (현재 5858 고정 허용/무한재사용)
- [✅] 비밀번호 해싱(bcrypt)
- [❌] 초기 사용자 설정 (기본 등급/VIP/토큰 초기값 등 일부 값은 모델기본값,  정책 합의 필요)


- [✅] 회원가입 후 토큰 발급
- [✅] 로그인 API (POST /api/auth/login)
  - 체크 방법: 올바른/잘못된 site_id와 비밀번호로 로그인 시도
  - 검증/서비스에  기준: 인증 성공 시 JWT 토큰 발급, 실패 시 401 오류 
  - 체크 대상:
- [✅] 인증 로직 (site_id + password 기반)
- [✅] 로그인 시도 횟수 제한(락아웃): 최근 실패 5회 시 10분간 429 응답 (env: LOGIN_MAX_FAILED_ATTEMPTS, LOGIN_LOCKOUT_MINUTES)
- [✅] 최근 로그인 시간 업데이트
- [✅] 액세스 토큰 발급 (HS256, 만료는 환경변수 JWT_EXPIRE_MINUTES, 기본 30분)
- [✅] 리프레시 토큰 저장소 (DB) — 로그인/회원가입 시 refresh_token 발급 및 저장, /api/auth/refresh에서 검증/회전, /api/auth/logout(-all)에서 폐기
- [✅] 사용자 정보 응답 별칭 (GET /api/auth/me) — `/api/users/profile`과 동치

[✅] JWT 토큰 발급/갱신 API
  - 체크 방법: 만료된 토큰으로 갱신 요청, 유효한 토큰으로 보호된 API 접근
  - 검증 기준: 토큰 만료/갱신 메커니즘이 정상 작동 
  - 체크 대상:- [✅] 토큰 갱신 엔드포인트 (POST /api/auth/refresh) — Authorization Bearer 또는 { refresh_token } 본문 허용, 응답에 신규 access_token 반환
  - [✅] 유효기간 설정 — 환경변수 JWT_EXPIRE_MINUTES (기본 30분)
    - [✅] 토큰 블랙리스트 (구현 완료)
  - [✅] 토큰 검증 로직 (python-jose)
    - [✅] 동시 세션 관리 (구현 완료)
    - [✅] 강제 로그아웃 기능 (구현 완료)

- [✅] 사용자 정보 조회 API (GET /api/auth/me)
  - 체크 방법: JWT 토큰으로 보호된 엔드포인트 접근
  - 검증 기준: 유효한 토큰으로 사용자 정보 반환, 무효한 토큰은 401 오류 
  - 비고: `/api/users/profile`과 데이터 동치. 테스트로 상호 일치 확인.

    
### 사용자 여정 2: 메인 루프
- [✅] 프로필 조회 API (GET /api/users/profile, GET /api/auth/me; 타인: GET /api/users/{user_id})
  - 체크 방법: 자신/타인의 프로필 조회 시도, 인증 토큰 없이 접근 시도
  - 검증 기준: 본인 정보는 상세 조회, 타인 정보는 제한적 조회 또는 차단
  - 현재 상태: OpenAPI 기준으로 self 엔드포인트는 `/api/users/profile`이며, `/api/users/{id}/profile`는 노출되지 않음. `GET /api/auth/me`는 self와 동치. 타인 조회는 `GET /api/users/{user_id}`로 제한 정보 제공.
  - 체크 대상:
    - [✅] 권한 기반 정보 필터링 (본인/타인 구분 로직 구현)
    - [✅] 기본 사용자 정보 조회 (닉네임, 토큰, 랭크)
  - [✅] 활동 통계 계산 (/api/users/stats 집계 구현 완료)
  - [✅] 진행 중인 미션정보 (/api/missions, 인증 사용자 기준 목록/보상 수령 연동)
    - [✅] 보유 토큰/통화 정보 (사이버 토큰 조회 완료)
  - 완료된 작업:
    -  backend/app/routers/users.py: 프로필 API 구현 (Raw SQL 사용)
    -  권한별 데이터 필터링 로직 (본인/타인 구분)
    -  기본 사용자 정보 조회 (ID, 닉네임, 토큰, 랭크)
    -  프론트엔드 컴포넌트 정리 (중복 제거, ProfileHeader 통합)
    -  API 응답 구조 정의 및 테스트 완료
  - 테스트 결과:
    -  GET /api/users/profile → 200 OK (self)
    -  GET /api/auth/me → 200 OK (self와 동치)
    -  GET /api/users/{user_id} → 200 OK (타인 제한 정보), 무인증 접근 시 401

    -  중복 컴포넌트 정리 (ModernProfileHeader 제거)
  - 향후 개선사항:
    - [✅] 상세 활동 통계 계산 구현 (/api/users/stats: UserAction/GameStats 집계 기반)
    - [✅]  미션 진행도 API 연동 (/api/missions, /api/missions/{id}/claim에 인증 연동)
    - [✅] 타인 프로필 조회 시 제한적 정보 필터링 (PublicUserResponse 스키마 도입)
    - [✅] 인증 토큰 기반 접근 제어 강화 (missions 라우터에 get_current_user 적용)

    구현 포인트:
    - backend/app/services/user_service.py: get_user_stats 고도화(집계 계산, win_rate 등)
    - backend/app/routers/missions.py: 하드코딩된 user_id 제거→get_current_user로 교체
    - backend/app/schemas/user.py: PublicUserResponse 추가(타인 제한 정보)
    - backend/app/routers/users.py: GET /api/users/{user_id} 응답을 UserResponse|PublicUserResponse로 분기


- [✅] 슬롯 게임 API (POST /api/actions/SLOT_SPIN)
  - 체크 방법: 연속 스핀 시도, 확률 분포 검증을 위한 대량 요청 테스트
  - 검증 기준: 스트릭 카운트 증가, 변동 비율 보상 로직 정상 동작
  - 체크 대상:
  - [✅] 슬롯 스핀 확률 테이블 (app.core.config.settings.SLOT_SYMBOL_WEIGHTS로 외부화)
  - [✅] 스트릭/연속 보상 메커니즘 (Redis streak 카운터 + 승리 보너스 최대 +20%, ±5% 변동)
  - [✅] 결과 결정 알고리즘 (심볼 가중치 기반 3릴 + 페어/트리플 승리 판정)
  - [✅] 랜덤 생성기 품질 (Python random 사용; CI 시드 고정 검토)
  - [✅] 보상 지급 연동 (베팅 차감/승리금 반영)
  - [✅] 사용자 액션 로깅 (SLOT_SPIN, streak 포함)

- 추가 테스트:
- [✅] test_slot_distribution_sanity.py (300회 샘플 분포 및 평균 승리 추세 스모크)

- [✅]가챠 스핀 API (POST /api/games/gacha/pull)
- 체크 방법: 다양한 등급의 아이템 드롭 확률 테스트 (1000회 이상 시뮬레이션)
- 검증 기준: 확률 분포가 설정값의 ±5% 이내, 로그 정확히 기록
- 체크 대상:
- [✅] 등급별 아이템 확률 테이블 (Legendary/Epic/Rare/Common + Near_Miss 변형; service DEFAULT_RARITY_TABLE 및 환경변수 오버라이드)
- [✅] 천장/보장 메커니즘 (90회 실패 시 Epic 보장, animation_type=pity)
- [✅] 가챠 비용 차감 로직 (1뽑 50, 10뽑 450 할인)
- [✅] 아이템 지급 로직 (near_miss 매핑 후 실제 rarity로 지급)
- [✅] 확률 공개 정보 (/api/games/gacha/config)
- [✅] 가챠 결과 히스토리 (/api/games/gacha/stats + UserAction 로그에 결과/연출 기록)
- 테스트 허용오차: ±5% (테스트 내 random.seed 고정)

 [⚠️] 보상 지급 API (POST /api/rewards)
 - 체크 방법: 다양한 보상 유형 지급 테스트, 동시 다수 요청 처리 테스트
 - 검증 기준: 사용자 잔액/인벤토리 정확히 업데이트, 중복 지급 방지
 - 체크 대상:
- [✅] 보상 유형별 처리 (코인, 젬, 아이템) — TOKEN/COIN 통화 반영, ITEM 기록
- [✅] 트랜잭션 처리 (원자성) — Reward + UserReward 동시 커밋, 오류 시 롤백
- [✅] 중복 지급 방지 (idempotency) — UserAction(REWARD_GRANT + idempotency_key)로 재시도 안전
- [✅] 보상 히스토리 기록 — GET /api/rewards/users/{user_id}/rewards 페이지네이션, claimed_at 기준 정렬\
- [⚠️] 특별 보상 처리 (이벤트, 프로모션) — 범위 확장 시 추가 모델링 예정
- [✅] 알림 연동 (보상 지급 알림) — WebSocket best-effort 개인 알림 전송

검증 메모(2025-08-12):
- app/tests/test_rewards_distribution.py 2건 PASS. 목록 API는 UserReward↔Reward 조인으로 RewardItem(reward_id, reward_type, reward_value, awarded_at=claimed_at) 형태 반환하도록 수정.


### (2025-08-16) 변경 요약 / 세션 & 실시간 토큰
#### 변경 요약
- GameSession 테이블 추가(Alembic: 20250816_add_game_sessions_table) 및 인덱스.
- /api/games/session/start,end 영속화 (중복 409, 종료 시 total_* 업데이트) + /session/active.
- GameHistory SESSION_START/END 로깅.
- WebSocket: game_session 이벤트 확장(external_session_id 포함) + token_update 이벤트 신설(TokenService hook).

#### 검증 결과
- 코드 기준 라우터 중복 제거, 모델 필드 정합성(외부 UUID ↔ 내부 int PK) 확보.
- token_service 경로 add/deduct 시 비동기 token_update 브로드캐스트 트리거(루프 존재 시).
- 마이그레이션 실행 후 heads 단일성/인덱스 적용 필요 (alembic upgrade head 예정).

#### 다음 단계
1. pytest: 세션 시작/중복/종료/active/token_update 이벤트 수신 테스트.
2. token_update payload balance_coin/gem 분리 및 history_id 포함 여부 확장 검토.
3. 세션 내 라운드별 BET/WIN 자동 누적 및 ROI/리더보드 후속.

### 진행상황 체크리스트
- [✅] **Alembic 마이그레이션 충돌 해결** (테이블 중복, 컬럼 충돌 등)
- [✅] 기존 테이블 중복(OperationalError) 해결
- [✅] 마이그레이션 히스토리 정리 및 초기화
- [✅] 스키마 정합성 검증

- [✅] **롤백/다운그레이드 정상 동작** (운영/테스트 환경 모두)
- [✅] PostgreSQL 환경에서 롤백 테스트 (downgrade -1 → upgrade 왕복 성공)
- [✅] SQLite 제약조건 우회 방안 (일부 롤백 불가, 테이블 recreate/백업 권장)
- [✅] 안전한 롤백 전략 문서화 (초안 추가 아래 참고)

- [✅] **마이그레이션 의존성/순서 정합성 확보**
- [✅] 마이그레이션 체인 검증 (alembic current/head 단일, history 점검)
- [✅] FK/제약조건 순서 정리 (일부 점검 필요)
- [✅] 의존성 그래프 문서화 (초안 추가 아래 참고)

- [✅] **운영/테스트 DB 환경 분리** 및 .env/컨테이너 분리
- [✅] .env.test 생성 (테스트 DB/시크릿 분리)
- [✅] docker-compose.test.yml로 테스트 DB 격리 기동 검증
- [✅] CI에서 .env.test 사용하여 alembic+pytest 실행 (GitHub Actions 추가)

- [✅] **Kafka/Zookeeper 컨테이너 정상 기동** 
- (docker-compose, 네트워크, 포트, 네임 충돌 해결)
- [⚠️] **FastAPI Kafka 연동** (aiokafka/kafka-python 연결 설정, 
- 실제 Producer/Consumer 연동) — Producer OK, Consumer pending
- 소비자 초기화 개선: 파티션 assignment 대기 후 seek-to-beginning 적용 메시지 유실 방지), 
  pytest 실행 시 thread 기반 소비자 강제 및 고유 consumer group 사용
- 프로듀서 전송 확인: 동기 전송(future.get) 및 메타데이터 로그(topic/partition/offset) 출력 추가
- [✅] **Kafka 연동 자동화 테스트/문서화** (pytest 통합 테스트, 운영/테스트 환경 분리)

### 작업 체크리스트
- [✅] backend/requirements.txt에 aiokafka(or kafka-python) 추가 (kafka-python/aiokafka 이미 포함)
- [✅] 설정: app.core.config.settings에 Kafka 설정 키 정의 (KAFKA_BOOTSTRAP_SERVERS, KAFKA_ENABLED)
- [✅] 서비스: KafkaProducer/KafkaConsumer 래퍼 모듈 1개만 사용 (app/kafka_client.py 재사용)
- [✅] 엔드포인트: /api/kafka/produce, /api/kafka/health 추가 (app/routers/kafka_api.py)
- [✅] pytest 통합 테스트: 브로커 없으면 skip (app/tests/test_kafka_integration.py)
- [✅] 라운드트립 테스트 추가(app/tests/test_kafka_roundtrip.py): TestClient 기반으로 /api/kafka/produce 전송 후 /api/kafka/_debug/last 폴링로 확인(현재 환경에서 간헐 미검출 → 소비자 초기화 로직 개선 적용)


### 1. 백엔드 (Backend)
#### 핵심 인프라
- [✅] FastAPI 프로젝트 초기화 및 구조화 (routers, services, repositories, schemas/models)
- 체크 방법: 컨테이너에서 서버 기동 시 /docs 엔드포인트 정상 노출 확인
- 검증 기준: 프로젝트 구조가 Clean Architecture 원칙을 따름
- 체크 대상: (검증 결과)
- [✅] 프로젝트 디렉토리 구조 (routers/, services/, repositories/, schemas/, models/ 등) 존재
- [✅] main.py 엔트리 포인트 존재 및 라우터 포함/미들웨어 설정
- [✅] config.py (app/core/config.py)와 docker-compose(.env.test 포함)로 환경 설정 일원화
- [✅] middleware 설정 (SimpleLoggingMiddleware, CORS) 적용, 커스텀 에러 핸들러는 보류
- [✅] 의존성 주입 설정 (get_db 등 DI 패턴 사용 가능; 라우터에서 Depends 활용)
- [✅] API 문서화 설정 (Swagger /docs, /redoc 경로 활성)
- [✅] PostgreSQL 연동 및 SQLAlchemy ORM 설정 (구조/연결/세션/엔진 정상)
- 체크 방법: alembic upgrade head 실행 및 DB 연결 테스트
- 검증 기준: 모델 CRUD 작업이 오류 없이 수행됨
- 체크 대상:
- [✅] database.py 설정 파일 (엔진/세션, Postgres/SQLite fallback)
- [✅] SQLAlchemy Base 및 SessionLocal 관리 (app.database.Base)
- [✅] 환경 변수: POSTGRES_* / DATABASE_URL 지원 (compose.test에서 주입)
- [✅] 연결 옵션/echo 설정 및 연결 성공 로그 출력
- [✅] 트랜잭션 스코프(get_db DI) 제공
- [✅] 기본 모델 클래스는 각 모델 모듈에서 Base 상속으로 일관 사용
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨


- [✅] Alembic 마이그레이션 구성 및 적용 (구성/경로/스크립트/메타데이터연동정상)
- 체크 방법: alembic revision --autogenerate 명령으로 새 마이그레이션 생성
- 검증 기준: 테이블 스키마 변경이 올바르게 적용됨
- 체크 대상:
- [✅] alembic.ini 설정 파일 존재
- [✅] migrations(versions/) 구성 및 리비전 다수 존재, 단일 head 유지
- [✅] env.py: app.models.Base 메타데이터 사용, POSTGRES_* 환경에서 URL구성
- [✅] 초기/후속 마이그레이션 스크립트 존재(merge 포함) 및 순서 정합
- [✅] 롤백 지원: Postgres에서 downgrade/upgrade 왕복 검증 완료(로그참조), 
  - SQLite 제한은 문서화
- [✅] 의존성 순서 점검 및 merge로 단일 head 유지(f79d04ea1016 이후 head=20250810_align_users)
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨
  - [참고] SQLite 환경에서 롤백(downgrade) 불가(OperationalError: NOT NULL 컬럼 추가 불가) → 개발 환경에서는 recreate/백업 전략 병행 필요
  - 마이그레이션 체인/의존성 순서는 정상이나, 다운그레이드 시 DBMS별 제약(특히 SQLite)로 일부 롤백 불가
  - [✅] 운영 DB(PostgreSQL) 실전 검증 완료: 마이그레이션/롤백/의존성 순서 정상 동작 확인(테스트 스택 기준)


### DB 인프라 개선/정합성 체크리스트

- ✅ Alembic 마이그레이션 충돌 해결 (테이블 중복, 컬럼 충돌 등)
- ✅ 롤백/다운그레이드 정상 동작 (운영/테스트 환경 모두)
- ✅ 마이그레이션 의존성/순서 정합성 확보
- ✅ 운영/테스트 DB 환경 분리 및 .env/컨테이너 분리
- ❌ 주요 테이블/인덱스/제약조건 설계 확정
- ✅ 트랜잭션/원자성/정합성 테스트
- ✅ 데이터 정합성 검증(샘플 데이터, CRUD, FK 등) — 기본 CRUD/FK 스모크 통과
- ⚠️ 백업/복구 전략 수립 및 테스트
- 메모: 컨테이너 내부 덤프/복구 스니펫
- 백업: `docker exec cc_postgres pg_dump -U cc_user -d cc_webapp > backup_cc_webapp_$(Get-Date -Format yyyyMMddHHmmss).sql`
- 복구(주의: 데이터 삭제): `docker exec -i cc_postgres psql -U cc_user -d cc_webapp < backup.sql`
- ✅ 마이그레이션/정합성 자동화 테스트 스크립트 작성 — CI Alembic history + downgrade(-1)/upgrade head 추가
- ✅ 개선/이슈/해결내역 문서화
- ✅ Kafka 연동 (이벤트/실시간 데이터 처리) — 최소 연결/라운드트립(피크) 스모크 완료
- 체크 방법: Producer/Consumer 테스트, 메시지 발행/구독 확인
- 검증 기준: 메시지 손실 없이 전달되는지 확인
- 체크 대상:
- ✅ Kafka 연결 설정
- ✅ 토픽 정의 및 생성 — auto-create + CI KAFKA_TEST_TOPIC=cc_test_ci
- ✅ Producer 구현 (사용자 행동, 보상 이벤트 등)
- ✅ Consumer 그룹 설정 — 고유 consumer group/pytest 격리
- ✅ 오류 처리 및 재시도 메커니즘
- ❌ 스키마 레지스트리 연동 (필요시)

### 다음 단계(2025-08-11)
- [✅] app/tests/test_invite_validate_api.py 작성 및 통과: 유효/만료/사용초과/미존재 코드 케이스 + 응답 포맷 검증
- [✅] InviteCode 모델↔DB 스키마 정합성 정리: expires_at/max_uses/used_count/created_by 필드 통일, Alembic 보강
- [✅] 라우터 최소 등급 의존성(require_min_rank) 구현 및 데모 엔드포인트 적용(+403/200 테스트)
- [⚠️] 백업/복구 스크립트(ps1) 및 간단 Runbook 섹션 추가

- [❌] JWT 인증 및 권한 관리 (초대코드/닉네임 기반, VIP/등급별 접근제어)
  - 체크 방법: 토큰 발급/검증 테스트, 보호된 엔드포인트 접근 시도
  - 검증 기준: 인증 헤더 없이 접근 시 401, 권한 없는 경우 403 반환
  - 체크 대상:
- [✅] JWT 인코딩/디코딩 기능 (AuthService.create_access_token/verify_token 구현, 테스트 통과)
- [✅] 토큰 발급 엔드포인트 (/api/auth/signup, /api/auth/login, /api/auth/admin/login)
- [✅] 만료 시간 설정 (JWT_EXPIRE_MINUTES 환경변수, 기본 30분)
- [✅] 토큰 리프레시 메커니즘 (/api/auth/refresh, Authorization Bearer 혹은 body.refresh_token 허용)
- [✅] 역할 기반 접근 제어 (RBAC) — require_min_rank 의존성 및 /api/rbac/premium, /api/rbac/vip 데모로 검증
- [✅] VIP/PREMIUM/STANDARD 등급별 권한 — 서비스의 check_rank_access 적용 및 테스트 보강 완료

### 다음 단계(추가 — 2025-08-15)
- [✅] Redis 키 전략/멱등키 설계 반영(구매 API/서비스 레벨)
- [✅] DB 스키마 도출 및 Alembic 마이그레이션 초안 작성(테이블/인덱스/제약) *(기존 20250813/20250815 리비전 집합 활용 – 신규 초안 불필요 판단)*
- [✅] 문서 보강: Admin/Shop 예시 페이로드/응답 및 reason 코드 표 추가, FE 연동 가이드 업데이트


- [❌] 테스트 코드(Pytest) 및 에러/로깅/문서화
  - 체크 방법: pytest -v 실행, 코드 커버리지 확인
  - 검증 기준: 핵심 기능 80% 이상 테스트 커버리지, 예외 처리 문서화
  - 체크 대상:
- [❌] 단위 테스트 (서비스, 리포지토리)
- [❌] 통합 테스트 (API 엔드포인트)
- [❌] 로깅 설정 (구조화된 로그)
- [❌] 에러 핸들링 미들웨어
- [❌] 사용자 정의 예외 클래스
- [❌] API 문서화 (OpenAPI/Swagger)


### 사용자 여정 1: 진입 및 등록
- [✅] 초대코드 유효성 검증 API (/api/invite/validate)
  - 체크 방법: 유효/만료/존재하지 않는 코드로 API 호출 
  - 검증 기준: 적절한 HTTP 상태 코드와 응답 메시지 반환 
  - 체크 대상: 코드는 고정값 5858 ✅ 테스트 완료 - 무한재사용 구현됨
- [✅] 유효성 검사 로직 — 다양한 케이스(유효/만료/사용초과/미존재) 테스트로 검증
- [✅] 만료 시간 검사 — expires_at 기준 비교로 동작 확인
- [✅] 사용 횟수 제한 검사 — None=무제한, 정수=남은횟수 계산 로직 검증
- [⚠️] 코드 보안 (예측 불가능성) — DEFAULT_INVITE_CODE 난수화 권장(운영 시 고정값 금지)
- [✅] 응답 포맷 (is_valid/error_message/code/expires_at/remaining_uses) — OpenAPI와 일치 검증
- 메모(2025-08-11): pytest.ini가 app/tests만 인식하므로 backend/tests 하 초대코드 테스트는 무시됨. app/tests/test_invite_validate.py 추가 필요. 또한 InviteCode 모델에 expires_at/max_uses/used_count 필드가 누락된 구현이 존재(simple_auth_models 등); 실제 DB/마이그레이션과 정합성 재검증 필요.

- [✅] 회원가입 API (POST /api/auth/signup)
  - 체크 방법: 유효한 초대코드와 닉네임으로 회원가입 시도
  - 검증 기준: 성공 시 사용자 생성 및 JWT 토큰 발급, 중복/오류 시 적절한 오류 응답 됨
- 체크 대상:
- [✅] 필수 필드 유효성 검사 (site_id, nickname, phone_number?, password, invite_code)
- [✅] 닉네임/아이디 중복 검사
- [✅] 초대코드 사용 처리 (현재 5858 고정 허용/무한재사용)
- [✅] 비밀번호 해싱(bcrypt)
- [❌] 초기 사용자 설정 (기본 등급/VIP/토큰 초기값 등 일부 값은 모델기본값,  정책 합의 필요)


- [✅] 회원가입 후 토큰 발급
- [✅] 로그인 API (POST /api/auth/login)
  - 체크 방법: 올바른/잘못된 site_id와 비밀번호로 로그인 시도
  - 검증/서비스에  기준: 인증 성공 시 JWT 토큰 발급, 실패 시 401 오류 
  - 체크 대상:
- [✅] 인증 로직 (site_id + password 기반)
- [✅] 로그인 시도 횟수 제한(락아웃): 최근 실패 5회 시 10분간 429 응답 (env: LOGIN_MAX_FAILED_ATTEMPTS, LOGIN_LOCKOUT_MINUTES)
- [✅] 최근 로그인 시간 업데이트
- [✅] 액세스 토큰 발급 (HS256, 만료는 환경변수 JWT_EXPIRE_MINUTES, 기본 30분)
- [✅] 리프레시 토큰 저장소 (DB) — 로그인/회원가입 시 refresh_token 발급 및 저장, /api/auth/refresh에서 검증/회전, /api/auth/logout(-all)에서 폐기
- [✅] 사용자 정보 응답 별칭 (GET /api/auth/me) — `/api/users/profile`과 동치

[✅] JWT 토큰 발급/갱신 API
  - 체크 방법: 만료된 토큰으로 갱신 요청, 유효한 토큰으로 보호된 API 접근
  - 검증 기준: 토큰 만료/갱신 메커니즘이 정상 작동 
  - 체크 대상:- [✅] 토큰 갱신 엔드포인트 (POST /api/auth/refresh) — Authorization Bearer 또는 { refresh_token } 본문 허용, 응답에 신규 access_token 반환
  - [✅] 유효기간 설정 — 환경변수 JWT_EXPIRE_MINUTES (기본 30분)
    - [✅] 토큰 블랙리스트 (구현 완료)
  - [✅] 토큰 검증 로직 (python-jose)
    - [✅] 동시 세션 관리 (구현 완료)
    - [✅] 강제 로그아웃 기능 (구현 완료)

- [✅] 사용자 정보 조회 API (GET /api/auth/me)
  - 체크 방법: JWT 토큰으로 보호된 엔드포인트 접근
  - 검증 기준: 유효한 토큰으로 사용자 정보 반환, 무효한 토큰은 401 오류 
  - 비고: `/api/users/profile`과 데이터 동치. 테스트로 상호 일치 확인.

    
### 사용자 여정 2: 메인 루프
- [✅] 프로필 조회 API (GET /api/users/profile, GET /api/auth/me; 타인: GET /api/users/{user_id})
  - 체크 방법: 자신/타인의 프로필 조회 시도, 인증 토큰 없이 접근 시도
  - 검증 기준: 본인 정보는 상세 조회, 타인 정보는 제한적 조회 또는 차단
  - 현재 상태: OpenAPI 기준으로 self 엔드포인트는 `/api/users/profile`이며, `/api/users/{id}/profile`는 노출되지 않음. `GET /api/auth/me`는 self와 동치. 타인 조회는 `GET /api/users/{user_id}`로 제한 정보 제공.
  - 체크 대상:
    - [✅] 권한 기반 정보 필터링 (본인/타인 구분 로직 구현)
    - [✅] 기본 사용자 정보 조회 (닉네임, 토큰, 랭크)
  - [✅] 활동 통계 계산 (/api/users/stats 집계 구현 완료)
  - [✅] 진행 중인 미션정보 (/api/missions, 인증 사용자 기준 목록/보상 수령 연동)
    - [✅] 보유 토큰/통화 정보 (사이버 토큰 조회 완료)
  - 완료된 작업:
    -  backend/app/routers/users.py: 프로필 API 구현 (Raw SQL 사용)
    -  권한별 데이터 필터링 로직 (본인/타인 구분)
    -  기본 사용자 정보 조회 (ID, 닉네임, 토큰, 랭크)
    -  프론트엔드 컴포넌트 정리 (중복 제거, ProfileHeader 통합)
    -  API 응답 구조 정의 및 테스트 완료
  - 테스트 결과:
    -  GET /api/users/profile → 200 OK (self)
    -  GET /api/auth/me → 200 OK (self와 동치)
    -  GET /api/users/{user_id} → 200 OK (타인 제한 정보), 무인증 접근 시 401

    -  중복 컴포넌트 정리 (ModernProfileHeader 제거)
  - 향후 개선사항:
    - [✅] 상세 활동 통계 계산 구현 (/api/users/stats: UserAction/GameStats 집계 기반)
    - [✅]  미션 진행도 API 연동 (/api/missions, /api/missions/{id}/claim에 인증 연동)
    - [✅] 타인 프로필 조회 시 제한적 정보 필터링 (PublicUserResponse 스키마 도입)
    - [✅] 인증 토큰 기반 접근 제어 강화 (missions 라우터에 get_current_user 적용)

    구현 포인트:
    - backend/app/services/user_service.py: get_user_stats 고도화(집계 계산, win_rate 등)
    - backend/app/routers/missions.py: 하드코딩된 user_id 제거→get_current_user로 교체
    - backend/app/schemas/user.py: PublicUserResponse 추가(타인 제한 정보)
    - backend/app/routers/users.py: GET /api/users/{user_id} 응답을 UserResponse|PublicUserResponse로 분기


- [✅] 슬롯 게임 API (POST /api/actions/SLOT_SPIN)
  - 체크 방법: 연속 스핀 시도, 확률 분포 검증을 위한 대량 요청 테스트
  - 검증 기준: 스트릭 카운트 증가, 변동 비율 보상 로직 정상 동작
  - 체크 대상:
  - [✅] 슬롯 스핀 확률 테이블 (app.core.config.settings.SLOT_SYMBOL_WEIGHTS로 외부화)
  - [✅] 스트릭/연속 보상 메커니즘 (Redis streak 카운터 + 승리 보너스 최대 +20%, ±5% 변동)
  - [✅] 결과 결정 알고리즘 (심볼 가중치 기반 3릴 + 페어/트리플 승리 판정)
  - [✅] 랜덤 생성기 품질 (Python random 사용; CI 시드 고정 검토)
  - [✅] 보상 지급 연동 (베팅 차감/승리금 반영)
  - [✅] 사용자 액션 로깅 (SLOT_SPIN, streak 포함)

- 추가 테스트:
- [✅] test_slot_distribution_sanity.py (300회 샘플 분포 및 평균 승리 추세 스모크)

- [✅]가챠 스핀 API (POST /api/games/gacha/pull)
- 체크 방법: 다양한 등급의 아이템 드롭 확률 테스트 (1000회 이상 시뮬레이션)
- 검증 기준: 확률 분포가 설정값의 ±5% 이내, 로그 정확히 기록
- 체크 대상:
- [✅] 등급별 아이템 확률 테이블 (Legendary/Epic/Rare/Common + Near_Miss 변형; service DEFAULT_RARITY_TABLE 및 환경변수 오버라이드)
- [✅] 천장/보장 메커니즘 (90회 실패 시 Epic 보장, animation_type=pity)
- [✅] 가챠 비용 차감 로직 (1뽑 50, 10뽑 450 할인)
- [✅] 아이템 지급 로직 (near_miss 매핑 후 실제 rarity로 지급)
- [✅] 확률 공개 정보 (/api/games/gacha/config)
- [✅] 가챠 결과 히스토리 (/api/games/gacha/stats + UserAction 로그에 결과/연출 기록)
- 테스트 허용오차: ±5% (테스트 내 random.seed 고정)

 [⚠️] 보상 지급 API (POST /api/rewards)
 - 체크 방법: 다양한 보상 유형 지급 테스트, 동시 다수 요청 처리 테스트
 - 검증 기준: 사용자 잔액/인벤토리 정확히 업데이트, 중복 지급 방지
 - 체크 대상:
- [✅] 보상 유형별 처리 (코인, 젬, 아이템) — TOKEN/COIN 통화 반영, ITEM 기록
- [✅] 트랜잭션 처리 (원자성) — Reward + UserReward 동시 커밋, 오류 시 롤백
- [✅] 중복 지급 방지 (idempotency) — UserAction(REWARD_GRANT + idempotency_key)로 재시도 안전
- [✅] 보상 히스토리 기록 — GET /api/rewards/users/{user_id}/rewards 페이지네이션, claimed_at 기준 정렬\
- [⚠️] 특별 보상 처리 (이벤트, 프로모션) — 범위 확장 시 추가 모델링 예정
- [✅] 알림 연동 (보상 지급 알림) — WebSocket best-effort 개인 알림 전송

검증 메모(2025-08-12):
- app/tests/test_rewards_distribution.py 2건 PASS. 목록 API는 UserReward↔Reward 조인으로 RewardItem(reward_id, reward_type, reward_value, awarded_at=claimed_at) 형태 반환하도록 수정.


### (2025-08-16) 변경 요약 / 세션 & 실시간 토큰
#### 변경 요약
- GameSession 테이블 추가(Alembic: 20250816_add_game_sessions_table) 및 인덱스.
- /api/games/session/start,end 영속화 (중복 409, 종료 시 total_* 업데이트) + /session/active.
- GameHistory SESSION_START/END 로깅.
- WebSocket: game_session 이벤트 확장(external_session_id 포함) + token_update 이벤트 신설(TokenService hook).

#### 검증 결과
- 코드 기준 라우터 중복 제거, 모델 필드 정합성(외부 UUID ↔ 내부 int PK) 확보.
- token_service 경로 add/deduct 시 비동기 token_update 브로드캐스트 트리거(루프 존재 시).
- 마이그레이션 실행 후 heads 단일성/인덱스 적용 필요 (alembic upgrade head 예정).

#### 다음 단계
1. pytest: 세션 시작/중복/종료/active/token_update 이벤트 수신 테스트.
2. token_update payload balance_coin/gem 분리 및 history_id 포함 여부 확장 검토.
3. 세션 내 라운드별 BET/WIN 자동 누적 및 ROI/리더보드 후속.

### 진행상황 체크리스트
- [✅] **Alembic 마이그레이션 충돌 해결** (테이블 중복, 컬럼 충돌 등)
- [✅] 기존 테이블 중복(OperationalError) 해결
- [✅] 마이그레이션 히스토리 정리 및 초기화
- [✅] 스키마 정합성 검증

- [✅] **롤백/다운그레이드 정상 동작** (운영/테스트 환경 모두)
- [✅] PostgreSQL 환경에서 롤백 테스트 (downgrade -1 → upgrade 왕복 성공)
- [✅] SQLite 제약조건 우회 방안 (일부 롤백 불가, 테이블 recreate/백업 권장)
- [✅] 안전한 롤백 전략 문서화 (초안 추가 아래 참고)

- [✅] **마이그레이션 의존성/순서 정합성 확보**
- [✅] 마이그레이션 체인 검증 (alembic current/head 단일, history 점검)
- [✅] FK/제약조건 순서 정리 (일부 점검 필요)
- [✅] 의존성 그래프 문서화 (초안 추가 아래 참고)

- [✅] **운영/테스트 DB 환경 분리** 및 .env/컨테이너 분리
- [✅] .env.test 생성 (테스트 DB/시크릿 분리)
- [✅] docker-compose.test.yml로 테스트 DB 격리 기동 검증
- [✅] CI에서 .env.test 사용하여 alembic+pytest 실행 (GitHub Actions 추가)

- [✅] **Kafka/Zookeeper 컨테이너 정상 기동** 
- (docker-compose, 네트워크, 포트, 네임 충돌 해결)
- [⚠️] **FastAPI Kafka 연동** (aiokafka/kafka-python 연결 설정, 
- 실제 Producer/Consumer 연동) — Producer OK, Consumer pending
- 소비자 초기화 개선: 파티션 assignment 대기 후 seek-to-beginning 적용 메시지 유실 방지), 
  pytest 실행 시 thread 기반 소비자 강제 및 고유 consumer group 사용
- 프로듀서 전송 확인: 동기 전송(future.get) 및 메타데이터 로그(topic/partition/offset) 출력 추가
- [✅] **Kafka 연동 자동화 테스트/문서화** (pytest 통합 테스트, 운영/테스트 환경 분리)

### 작업 체크리스트
- [✅] backend/requirements.txt에 aiokafka(or kafka-python) 추가 (kafka-python/aiokafka 이미 포함)
- [✅] 설정: app.core.config.settings에 Kafka 설정 키 정의 (KAFKA_BOOTSTRAP_SERVERS, KAFKA_ENABLED)
- [✅] 서비스: KafkaProducer/KafkaConsumer 래퍼 모듈 1개만 사용 (app/kafka_client.py 재사용)
- [✅] 엔드포인트: /api/kafka/produce, /api/kafka/health 추가 (app/routers/kafka_api.py)
- [✅] pytest 통합 테스트: 브로커 없으면 skip (app/tests/test_kafka_integration.py)
- [✅] 라운드트립 테스트 추가(app/tests/test_kafka_roundtrip.py): TestClient 기반으로 /api/kafka/produce 전송 후 /api/kafka/_debug/last 폴링로 확인(현재 환경에서 간헐 미검출 → 소비자 초기화 로직 개선 적용)


### 1. 백엔드 (Backend)
#### 핵심 인프라
- [✅] FastAPI 프로젝트 초기화 및 구조화 (routers, services, repositories, schemas/models)
- 체크 방법: 컨테이너에서 서버 기동 시 /docs 엔드포인트 정상 노출 확인
- 검증 기준: 프로젝트 구조가 Clean Architecture 원칙을 따름
- 체크 대상: (검증 결과)
- [✅] 프로젝트 디렉토리 구조 (routers/, services/, repositories/, schemas/, models/ 등) 존재
- [✅] main.py 엔트리 포인트 존재 및 라우터 포함/미들웨어 설정
- [✅] config.py (app/core/config.py)와 docker-compose(.env.test 포함)로 환경 설정 일원화
- [✅] middleware 설정 (SimpleLoggingMiddleware, CORS) 적용, 커스텀 에러 핸들러는 보류
- [✅] 의존성 주입 설정 (get_db 등 DI 패턴 사용 가능; 라우터에서 Depends 활용)
- [✅] API 문서화 설정 (Swagger /docs, /redoc 경로 활성)
- [✅] PostgreSQL 연동 및 SQLAlchemy ORM 설정 (구조/연결/세션/엔진 정상)
- 체크 방법: alembic upgrade head 실행 및 DB 연결 테스트
- 검증 기준: 모델 CRUD 작업이 오류 없이 수행됨
- 체크 대상:
- [✅] database.py 설정 파일 (엔진/세션, Postgres/SQLite fallback)
- [✅] SQLAlchemy Base 및 SessionLocal 관리 (app.database.Base)
- [✅] 환경 변수: POSTGRES_* / DATABASE_URL 지원 (compose.test에서 주입)
- [✅] 연결 옵션/echo 설정 및 연결 성공 로그 출력
- [✅] 트랜잭션 스코프(get_db DI) 제공
- [✅] 기본 모델 클래스는 각 모델 모듈에서 Base 상속으로 일관 사용
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨


- [✅] Alembic 마이그레이션 구성 및 적용 (구성/경로/스크립트/메타데이터연동정상)
- 체크 방법: alembic revision --autogenerate 명령으로 새 마이그레이션 생성
- 검증 기준: 테이블 스키마 변경이 올바르게 적용됨
- 체크 대상:
- [✅] alembic.ini 설정 파일 존재
- [✅] migrations(versions/) 구성 및 리비전 다수 존재, 단일 head 유지
- [✅] env.py: app.models.Base 메타데이터 사용, POSTGRES_* 환경에서 URL구성
- [✅] 초기/후속 마이그레이션 스크립트 존재(merge 포함) 및 순서 정합
- [✅] 롤백 지원: Postgres에서 downgrade/upgrade 왕복 검증 완료(로그참조), 
  - SQLite 제한은 문서화
- [✅] 의존성 순서 점검 및 merge로 단일 head 유지(f79d04ea1016 이후 head=20250810_align_users)
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨
  - [참고] SQLite 환경에서 롤백(downgrade) 불가(OperationalError: NOT NULL 컬럼 추가 불가) → 개발 환경에서는 recreate/백업 전략 병행 필요
  - 마이그레이션 체인/의존성 순서는 정상이나, 다운그레이드 시 DBMS별 제약(특히 SQLite)로 일부 롤백 불가
  - [✅] 운영 DB(PostgreSQL) 실전 검증 완료: 마이그레이션/롤백/의존성 순서 정상 동작 확인(테스트 스택 기준)


### DB 인프라 개선/정합성 체크리스트

- ✅ Alembic 마이그레이션 충돌 해결 (테이블 중복, 컬럼 충돌 등)
- ✅ 롤백/다운그레이드 정상 동작 (운영/테스트 환경 모두)
- ✅ 마이그레이션 의존성/순서 정합성 확보
- ✅ 운영/테스트 DB 환경 분리 및 .env/컨테이너 분리
- ❌ 주요 테이블/인덱스/제약조건 설계 확정
- ✅ 트랜잭션/원자성/정합성 테스트
- ✅ 데이터 정합성 검증(샘플 데이터, CRUD, FK 등) — 기본 CRUD/FK 스모크 통과
- ⚠️ 백업/복구 전략 수립 및 테스트
- 메모: 컨테이너 내부 덤프/복구 스니펫
- 백업: `docker exec cc_postgres pg_dump -U cc_user -d cc_webapp > backup_cc_webapp_$(Get-Date -Format yyyyMMddHHmmss).sql`
- 복구(주의: 데이터 삭제): `docker exec -i cc_postgres psql -U cc_user -d cc_webapp < backup.sql`
- ✅ 마이그레이션/정합성 자동화 테스트 스크립트 작성 — CI Alembic history + downgrade(-1)/upgrade head 추가
- ✅ 개선/이슈/해결내역 문서화
- ✅ Kafka 연동 (이벤트/실시간 데이터 처리) — 최소 연결/라운드트립(피크) 스모크 완료
- 체크 방법: Producer/Consumer 테스트, 메시지 발행/구독 확인
- 검증 기준: 메시지 손실 없이 전달되는지 확인
- 체크 대상:
- ✅ Kafka 연결 설정
- ✅ 토픽 정의 및 생성 — auto-create + CI KAFKA_TEST_TOPIC=cc_test_ci
- ✅ Producer 구현 (사용자 행동, 보상 이벤트 등)
- ✅ Consumer 그룹 설정 — 고유 consumer group/pytest 격리
- ✅ 오류 처리 및 재시도 메커니즘
- ❌ 스키마 레지스트리 연동 (필요시)

### 다음 단계(2025-08-11)
- [✅] app/tests/test_invite_validate_api.py 작성 및 통과: 유효/만료/사용초과/미존재 코드 케이스 + 응답 포맷 검증
- [✅] InviteCode 모델↔DB 스키마 정합성 정리: expires_at/max_uses/used_count/created_by 필드 통일, Alembic 보강
- [✅] 라우터 최소 등급 의존성(require_min_rank) 구현 및 데모 엔드포인트 적용(+403/200 테스트)
- [⚠️] 백업/복구 스크립트(ps1) 및 간단 Runbook 섹션 추가

- [❌] JWT 인증 및 권한 관리 (초대코드/닉네임 기반, VIP/등급별 접근제어)
  - 체크 방법: 토큰 발급/검증 테스트, 보호된 엔드포인트 접근 시도
  - 검증 기준: 인증 헤더 없이 접근 시 401, 권한 없는 경우 403 반환
  - 체크 대상:
- [✅] JWT 인코딩/디코딩 기능 (AuthService.create_access_token/verify_token 구현, 테스트 통과)
- [✅] 토큰 발급 엔드포인트 (/api/auth/signup, /api/auth/login, /api/auth/admin/login)
- [✅] 만료 시간 설정 (JWT_EXPIRE_MINUTES 환경변수, 기본 30분)
- [✅] 토큰 리프레시 메커니즘 (/api/auth/refresh, Authorization Bearer 혹은 body.refresh_token 허용)
- [✅] 역할 기반 접근 제어 (RBAC) — require_min_rank 의존성 및 /api/rbac/premium, /api/rbac/vip 데모로 검증
- [✅] VIP/PREMIUM/STANDARD 등급별 권한 — 서비스의 check_rank_access 적용 및 테스트 보강 완료

### 다음 단계(추가 — 2025-08-15)
- [✅] Redis 키 전략/멱등키 설계 반영(구매 API/서비스 레벨)
- [✅] DB 스키마 도출 및 Alembic 마이그레이션 초안 작성(테이블/인덱스/제약) *(기존 20250813/20250815 리비전 집합 활용 – 신규 초안 불필요 판단)*
- [✅] 문서 보강: Admin/Shop 예시 페이로드/응답 및 reason 코드 표 추가, FE 연동 가이드 업데이트


- [❌] 테스트 코드(Pytest) 및 에러/로깅/문서화
  - 체크 방법: pytest -v 실행, 코드 커버리지 확인
  - 검증 기준: 핵심 기능 80% 이상 테스트 커버리지, 예외 처리 문서화
  - 체크 대상:
- [❌] 단위 테스트 (서비스, 리포지토리)
- [❌] 통합 테스트 (API 엔드포인트)
- [❌] 로깅 설정 (구조화된 로그)
- [❌] 에러 핸들링 미들웨어
- [❌] 사용자 정의 예외 클래스
- [❌] API 문서화 (OpenAPI/Swagger)


### 사용자 여정 1: 진입 및 등록
- [✅] 초대코드 유효성 검증 API (/api/invite/validate)
  - 체크 방법: 유효/만료/존재하지 않는 코드로 API 호출 
  - 검증 기준: 적절한 HTTP 상태 코드와 응답 메시지 반환 
  - 체크 대상: 코드는 고정값 5858 ✅ 테스트 완료 - 무한재사용 구현됨
- [✅] 유효성 검사 로직 — 다양한 케이스(유효/만료/사용초과/미존재) 테스트로 검증
- [✅] 만료 시간 검사 — expires_at 기준 비교로 동작 확인
- [✅] 사용 횟수 제한 검사 — None=무제한, 정수=남은횟수 계산 로직 검증
- [⚠️] 코드 보안 (예측 불가능성) — DEFAULT_INVITE_CODE 난수화 권장(운영 시 고정값 금지)
- [✅] 응답 포맷 (is_valid/error_message/code/expires_at/remaining_uses) — OpenAPI와 일치 검증
- 메모(2025-08-11): pytest.ini가 app/tests만 인식하므로 backend/tests 하 초대코드 테스트는 무시됨. app/tests/test_invite_validate.py 추가 필요. 또한 InviteCode 모델에 expires_at/max_uses/used_count 필드가 누락된 구현이 존재(simple_auth_models 등); 실제 DB/마이그레이션과 정합성 재검증 필요.

- [✅] 회원가입 API (POST /api/auth/signup)
  - 체크 방법: 유효한 초대코드와 닉네임으로 회원가입 시도
  - 검증 기준: 성공 시 사용자 생성 및 JWT 토큰 발급, 중복/오류 시 적절한 오류 응답 됨
- 체크 대상:
- [✅] 필수 필드 유효성 검사 (site_id, nickname, phone_number?, password, invite_code)
- [✅] 닉네임/아이디 중복 검사
- [✅] 초대코드 사용 처리 (현재 5858 고정 허용/무한재사용)
- [✅] 비밀번호 해싱(bcrypt)
- [❌] 초기 사용자 설정 (기본 등급/VIP/토큰 초기값 등 일부 값은 모델기본값,  정책 합의 필요)


- [✅] 회원가입 후 토큰 발급
- [✅] 로그인 API (POST /api/auth/login)
  - 체크 방법: 올바른/잘못된 site_id와 비밀번호로 로그인 시도
  - 검증/서비스에  기준: 인증 성공 시 JWT 토큰 발급, 실패 시 401 오류 
  - 체크 대상:
- [✅] 인증 로직 (site_id + password 기반)
- [✅] 로그인 시도 횟수 제한(락아웃): 최근 실패 5회 시 10분간 429 응답 (env: LOGIN_MAX_FAILED_ATTEMPTS, LOGIN_LOCKOUT_MINUTES)
- [✅] 최근 로그인 시간 업데이트
- [✅] 액세스 토큰 발급 (HS256, 만료는 환경변수 JWT_EXPIRE_MINUTES, 기본 30분)
- [✅] 리프레시 토큰 저장소 (DB) — 로그인/회원가입 시 refresh_token 발급 및 저장, /api/auth/refresh에서 검증/회전, /api/auth/logout(-all)에서 폐기
- [✅] 사용자 정보 응답 별칭 (GET /api/auth/me) — `/api/users/profile`과 동치

[✅] JWT 토큰 발급/갱신 API
  - 체크 방법: 만료된 토큰으로 갱신 요청, 유효한 토큰으로 보호된 API 접근
  - 검증 기준: 토큰 만료/갱신 메커니즘이 정상 작동 
  - 체크 대상:- [✅] 토큰 갱신 엔드포인트 (POST /api/auth/refresh) — Authorization Bearer 또는 { refresh_token } 본문 허용, 응답에 신규 access_token 반환
  - [✅] 유효기간 설정 — 환경변수 JWT_EXPIRE_MINUTES (기본 30분)
    - [✅] 토큰 블랙리스트 (구현 완료)
  - [✅] 토큰 검증 로직 (python-jose)
    - [✅] 동시 세션 관리 (구현 완료)
    - [✅] 강제 로그아웃 기능 (구현 완료)

- [✅] 사용자 정보 조회 API (GET /api/auth/me)
  - 체크 방법: JWT 토큰으로 보호된 엔드포인트 접근
  - 검증 기준: 유효한 토큰으로 사용자 정보 반환, 무효한 토큰은 401 오류 
  - 비고: `/api/users/profile`과 데이터 동치. 테스트로 상호 일치 확인.

    
### 사용자 여정 2: 메인 루프
- [✅] 프로필 조회 API (GET /api/users/profile, GET /api/auth/me; 타인: GET /api/users/{user_id})
  - 체크 방법: 자신/타인의 프로필 조회 시도, 인증 토큰 없이 접근 시도
  - 검증 기준: 본인 정보는 상세 조회, 타인 정보는 제한적 조회 또는 차단
  - 현재 상태: OpenAPI 기준으로 self 엔드포인트는 `/api/users/profile`이며, `/api/users/{id}/profile`는 노출되지 않음. `GET /api/auth/me`는 self와 동치. 타인 조회는 `GET /api/users/{user_id}`로 제한 정보 제공.
  - 체크 대상:
    - [✅] 권한 기반 정보 필터링 (본인/타인 구분 로직 구현)
    - [✅] 기본 사용자 정보 조회 (닉네임, 토큰, 랭크)
  - [✅] 활동 통계 계산 (/api/users/stats 집계 구현 완료)
  - [✅] 진행 중인 미션정보 (/api/missions, 인증 사용자 기준 목록/보상 수령 연동)
    - [✅] 보유 토큰/통화 정보 (사이버 토큰 조회 완료)
  - 완료된 작업:
    -  backend/app/routers/users.py: 프로필 API 구현 (Raw SQL 사용)
    -  권한별 데이터 필터링 로직 (본인/타인 구분)
    -  기본 사용자 정보 조회 (ID, 닉네임, 토큰, 랭크)
    -  프론트엔드 컴포넌트 정리 (중복 제거, ProfileHeader 통합)
    -  API 응답 구조 정의 및 테스트 완료
  - 테스트 결과:
    -  GET /api/users/profile → 200 OK (self)
    -  GET /api/auth/me → 200 OK (self와 동치)
    -  GET /api/users/{user_id} → 200 OK (타인 제한 정보), 무인증 접근 시 401

    -  중복 컴포넌트 정리 (ModernProfileHeader 제거)
  - 향후 개선사항:
    - [✅] 상세 활동 통계 계산 구현 (/api/users/stats: UserAction/GameStats 집계 기반)
    - [✅]  미션 진행도 API 연동 (/api/missions, /api/missions/{id}/claim에 인증 연동)
    - [✅] 타인 프로필 조회 시 제한적 정보 필터링 (PublicUserResponse 스키마 도입)
    - [✅] 인증 토큰 기반 접근 제어 강화 (missions 라우터에 get_current_user 적용)

    구현 포인트:
    - backend/app/services/user_service.py: get_user_stats 고도화(집계 계산, win_rate 등)
    - backend/app/routers/missions.py: 하드코딩된 user_id 제거→get_current_user로 교체
    - backend/app/schemas/user.py: PublicUserResponse 추가(타인 제한 정보)
    - backend/app/routers/users.py: GET /api/users/{user_id} 응답을 UserResponse|PublicUserResponse로 분기


- [✅] 슬롯 게임 API (POST /api/actions/SLOT_SPIN)
  - 체크 방법: 연속 스핀 시도, 확률 분포 검증을 위한 대량 요청 테스트
  - 검증 기준: 스트릭 카운트 증가, 변동 비율 보상 로직 정상 동작
  - 체크 대상:
  - [✅] 슬롯 스핀 확률 테이블 (app.core.config.settings.SLOT_SYMBOL_WEIGHTS로 외부화)
  - [✅] 스트릭/연속 보상 메커니즘 (Redis streak 카운터 + 승리 보너스 최대 +20%, ±5% 변동)
  - [✅] 결과 결정 알고리즘 (심볼 가중치 기반 3릴 + 페어/트리플 승리 판정)
  - [✅] 랜덤 생성기 품질 (Python random 사용; CI 시드 고정 검토)
  - [✅] 보상 지급 연동 (베팅 차감/승리금 반영)
  - [✅] 사용자 액션 로깅 (SLOT_SPIN, streak 포함)

- 추가 테스트:
- [✅] test_slot_distribution_sanity.py (300회 샘플 분포 및 평균 승리 추세 스모크)

- [✅]가챠 스핀 API (POST /api/games/gacha/pull)
- 체크 방법: 다양한 등급의 아이템 드롭 확률 테스트 (1000회 이상 시뮬레이션)
- 검증 기준: 확률 분포가 설정값의 ±5% 이내, 로그 정확히 기록
- 체크 대상:
- [✅] 등급별 아이템 확률 테이블 (Legendary/Epic/Rare/Common + Near_Miss 변형; service DEFAULT_RARITY_TABLE 및 환경변수 오버라이드)
- [✅] 천장/보장 메커니즘 (90회 실패 시 Epic 보장, animation_type=pity)
- [✅] 가챠 비용 차감 로직 (1뽑 50, 10뽑 450 할인)
- [✅] 아이템 지급 로직 (near_miss 매핑 후 실제 rarity로 지급)
- [✅] 확률 공개 정보 (/api/games/gacha/config)
- [✅] 가챠 결과 히스토리 (/api/games/gacha/stats + UserAction 로그에 결과/연출 기록)
- 테스트 허용오차: ±5% (테스트 내 random.seed 고정)

 [⚠️] 보상 지급 API (POST /api/rewards)
 - 체크 방법: 다양한 보상 유형 지급 테스트, 동시 다수 요청 처리 테스트
 - 검증 기준: 사용자 잔액/인벤토리 정확히 업데이트, 중복 지급 방지
 - 체크 대상:
- [✅] 보상 유형별 처리 (코인, 젬, 아이템) — TOKEN/COIN 통화 반영, ITEM 기록
- [✅] 트랜잭션 처리 (원자성) — Reward + UserReward 동시 커밋, 오류 시 롤백
- [✅] 중복 지급 방지 (idempotency) — UserAction(REWARD_GRANT + idempotency_key)로 재시도 안전
- [✅] 보상 히스토리 기록 — GET /api/rewards/users/{user_id}/rewards 페이지네이션, claimed_at 기준 정렬\
- [⚠️] 특별 보상 처리 (이벤트, 프로모션) — 범위 확장 시 추가 모델링 예정
- [✅] 알림 연동 (보상 지급 알림) — WebSocket best-effort 개인 알림 전송

검증 메모(2025-08-12):
- app/tests/test_rewards_distribution.py 2건 PASS. 목록 API는 UserReward↔Reward 조인으로 RewardItem(reward_id, reward_type, reward_value, awarded_at=claimed_at) 형태 반환하도록 수정.


### (2025-08-16) 변경 요약 / 세션 & 실시간 토큰
#### 변경 요약
- GameSession 테이블 추가(Alembic: 20250816_add_game_sessions_table) 및 인덱스.
- /api/games/session/start,end 영속화 (중복 409, 종료 시 total_* 업데이트) + /session/active.
- GameHistory SESSION_START/END 로깅.
- WebSocket: game_session 이벤트 확장(external_session_id 포함) + token_update 이벤트 신설(TokenService hook).

#### 검증 결과
- 코드 기준 라우터 중복 제거, 모델 필드 정합성(외부 UUID ↔ 내부 int PK) 확보.
- token_service 경로 add/deduct 시 비동기 token_update 브로드캐스트 트리거(루프 존재 시).
- 마이그레이션 실행 후 heads 단일성/인덱스 적용 필요 (alembic upgrade head 예정).

#### 다음 단계
1. pytest: 세션 시작/중복/종료/active/token_update 이벤트 수신 테스트.
2. token_update payload balance_coin/gem 분리 및 history_id 포함 여부 확장 검토.
3. 세션 내 라운드별 BET/WIN 자동 누적 및 ROI/리더보드 후속.

### 진행상황 체크리스트
- [✅] **Alembic 마이그레이션 충돌 해결** (테이블 중복, 컬럼 충돌 등)
- [✅] 기존 테이블 중복(OperationalError) 해결
- [✅] 마이그레이션 히스토리 정리 및 초기화
- [✅] 스키마 정합성 검증

- [✅] **롤백/다운그레이드 정상 동작** (운영/테스트 환경 모두)
- [✅] PostgreSQL 환경에서 롤백 테스트 (downgrade -1 → upgrade 왕복 성공)
- [✅] SQLite 제약조건 우회 방안 (일부 롤백 불가, 테이블 recreate/백업 권장)
- [✅] 안전한 롤백 전략 문서화 (초안 추가 아래 참고)

- [✅] **마이그레이션 의존성/순서 정합성 확보**
- [✅] 마이그레이션 체인 검증 (alembic current/head 단일, history 점검)
- [✅] FK/제약조건 순서 정리 (일부 점검 필요)
- [✅] 의존성 그래프 문서화 (초안 추가 아래 참고)

- [✅] **운영/테스트 DB 환경 분리** 및 .env/컨테이너 분리
- [✅] .env.test 생성 (테스트 DB/시크릿 분리)
- [✅] docker-compose.test.yml로 테스트 DB 격리 기동 검증
- [✅] CI에서 .env.test 사용하여 alembic+pytest 실행 (GitHub Actions 추가)

- [✅] **Kafka/Zookeeper 컨테이너 정상 기동** 
- (docker-compose, 네트워크, 포트, 네임 충돌 해결)
- [⚠️] **FastAPI Kafka 연동** (aiokafka/kafka-python 연결 설정, 
- 실제 Producer/Consumer 연동) — Producer OK, Consumer pending
- 소비자 초기화 개선: 파티션 assignment 대기 후 seek-to-beginning 적용 메시지 유실 방지), 
  pytest 실행 시 thread 기반 소비자 강제 및 고유 consumer group 사용
- 프로듀서 전송 확인: 동기 전송(future.get) 및 메타데이터 로그(topic/partition/offset) 출력 추가
- [✅] **Kafka 연동 자동화 테스트/문서화** (pytest 통합 테스트, 운영/테스트 환경 분리)

### 작업 체크리스트
- [✅] backend/requirements.txt에 aiokafka(or kafka-python) 추가 (kafka-python/aiokafka 이미 포함)
- [✅] 설정: app.core.config.settings에 Kafka 설정 키 정의 (KAFKA_BOOTSTRAP_SERVERS, KAFKA_ENABLED)
- [✅] 서비스: KafkaProducer/KafkaConsumer 래퍼 모듈 1개만 사용 (app/kafka_client.py 재사용)
- [✅] 엔드포인트: /api/kafka/produce, /api/kafka/health 추가 (app/routers/kafka_api.py)
- [✅] pytest 통합 테스트: 브로커 없으면 skip (app/tests/test_kafka_integration.py)
- [✅] 라운드트립 테스트 추가(app/tests/test_kafka_roundtrip.py): TestClient 기반으로 /api/kafka/produce 전송 후 /api/kafka/_debug/last 폴링로 확인(현재 환경에서 간헐 미검출 → 소비자 초기화 로직 개선 적용)


### 1. 백엔드 (Backend)
#### 핵심 인프라
- [✅] FastAPI 프로젝트 초기화 및 구조화 (routers, services, repositories, schemas/models)
- 체크 방법: 컨테이너에서 서버 기동 시 /docs 엔드포인트 정상 노출 확인
- 검증 기준: 프로젝트 구조가 Clean Architecture 원칙을 따름
- 체크 대상: (검증 결과)
- [✅] 프로젝트 디렉토리 구조 (routers/, services/, repositories/, schemas/, models/ 등) 존재
- [✅] main.py 엔트리 포인트 존재 및 라우터 포함/미들웨어 설정
- [✅] config.py (app/core/config.py)와 docker-compose(.env.test 포함)로 환경 설정 일원화
- [✅] middleware 설정 (SimpleLoggingMiddleware, CORS) 적용, 커스텀 에러 핸들러는 보류
- [✅] 의존성 주입 설정 (get_db 등 DI 패턴 사용 가능; 라우터에서 Depends 활용)
- [✅] API 문서화 설정 (Swagger /docs, /redoc 경로 활성)
- [✅] PostgreSQL 연동 및 SQLAlchemy ORM 설정 (구조/연결/세션/엔진 정상)
- 체크 방법: alembic upgrade head 실행 및 DB 연결 테스트
- 검증 기준: 모델 CRUD 작업이 오류 없이 수행됨
- 체크 대상:
- [✅] database.py 설정 파일 (엔진/세션, Postgres/SQLite fallback)
- [✅] SQLAlchemy Base 및 SessionLocal 관리 (app.database.Base)
- [✅] 환경 변수: POSTGRES_* / DATABASE_URL 지원 (compose.test에서 주입)
- [✅] 연결 옵션/echo 설정 및 연결 성공 로그 출력
- [✅] 트랜잭션 스코프(get_db DI) 제공
- [✅] 기본 모델 클래스는 각 모델 모듈에서 Base 상속으로 일관 사용
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨


- [✅] Alembic 마이그레이션 구성 및 적용 (구성/경로/스크립트/메타데이터연동정상)
- 체크 방법: alembic revision --autogenerate 명령으로 새 마이그레이션 생성
- 검증 기준: 테이블 스키마 변경이 올바르게 적용됨
- 체크 대상:
- [✅] alembic.ini 설정 파일 존재
- [✅] migrations(versions/) 구성 및 리비전 다수 존재, 단일 head 유지
- [✅] env.py: app.models.Base 메타데이터 사용, POSTGRES_* 환경에서 URL구성
- [✅] 초기/후속 마이그레이션 스크립트 존재(merge 포함) 및 순서 정합
- [✅] 롤백 지원: Postgres에서 downgrade/upgrade 왕복 검증 완료(로그참조), 
  - SQLite 제한은 문서화
- [✅] 의존성 순서 점검 및 merge로 단일 head 유지(f79d04ea1016 이후 head=20250810_align_users)
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨
  - [참고] SQLite 환경에서 롤백(downgrade) 불가(OperationalError: NOT NULL 컬럼 추가 불가) → 개발 환경에서는 recreate/백업 전략 병행 필요
  - 마이그레이션 체인/의존성 순서는 정상이나, 다운그레이드 시 DBMS별 제약(특히 SQLite)로 일부 롤백 불가
  - [✅] 운영 DB(PostgreSQL) 실전 검증 완료: 마이그레이션/롤백/의존성 순서 정상 동작 확인(테스트 스택 기준)


### DB 인프라 개선/정합성 체크리스트

- ✅ Alembic 마이그레이션 충돌 해결 (테이블 중복, 컬럼 충돌 등)
- ✅ 롤백/다운그레이드 정상 동작 (운영/테스트 환경 모두)
- ✅ 마이그레이션 의존성/순서 정합성 확보
- ✅ 운영/테스트 DB 환경 분리 및 .env/컨테이너 분리
- ❌ 주요 테이블/인덱스/제약조건 설계 확정
- ✅ 트랜잭션/원자성/정합성 테스트
- ✅ 데이터 정합성 검증(샘플 데이터, CRUD, FK 등) — 기본 CRUD/FK 스모크 통과
- ⚠️ 백업/복구 전략 수립 및 테스트
- 메모: 컨테이너 내부 덤프/복구 스니펫
- 백업: `docker exec cc_postgres pg_dump -U cc_user -d cc_webapp > backup_cc_webapp_$(Get-Date -Format yyyyMMddHHmmss).sql`
- 복구(주의: 데이터 삭제): `docker exec -i cc_postgres psql -U cc_user -d cc_webapp < backup.sql`
- ✅ 마이그레이션/정합성 자동화 테스트 스크립트 작성 — CI Alembic history + downgrade(-1)/upgrade head 추가
- ✅ 개선/이슈/해결내역 문서화
- ✅ Kafka 연동 (이벤트/실시간 데이터 처리) — 최소 연결/라운드트립(피크) 스모크 완료
- 체크 방법: Producer/Consumer 테스트, 메시지 발행/구독 확인
- 검증 기준: 메시지 손실 없이 전달되는지 확인
- 체크 대상:
- ✅ Kafka 연결 설정
- ✅ 토픽 정의 및 생성 — auto-create + CI KAFKA_TEST_TOPIC=cc_test_ci
- ✅ Producer 구현 (사용자 행동, 보상 이벤트 등)
- ✅ Consumer 그룹 설정 — 고유 consumer group/pytest 격리
- ✅ 오류 처리 및 재시도 메커니즘
- ❌ 스키마 레지스트리 연동 (필요시)

### 다음 단계(2025-08-11)
- [✅] app/tests/test_invite_validate_api.py 작성 및 통과: 유효/만료/사용초과/미존재 코드 케이스 + 응답 포맷 검증
- [✅] InviteCode 모델↔DB 스키마 정합성 정리: expires_at/max_uses/used_count/created_by 필드 통일, Alembic 보강
- [✅] 라우터 최소 등급 의존성(require_min_rank) 구현 및 데모 엔드포인트 적용(+403/200 테스트)
- [⚠️] 백업/복구 스크립트(ps1) 및 간단 Runbook 섹션 추가

- [❌] JWT 인증 및 권한 관리 (초대코드/닉네임 기반, VIP/등급별 접근제어)
  - 체크 방법: 토큰 발급/검증 테스트, 보호된 엔드포인트 접근 시도
  - 검증 기준: 인증 헤더 없이 접근 시 401, 권한 없는 경우 403 반환
  - 체크 대상:
- [✅] JWT 인코딩/디코딩 기능 (AuthService.create_access_token/verify_token 구현, 테스트 통과)
- [✅] 토큰 발급 엔드포인트 (/api/auth/signup, /api/auth/login, /api/auth/admin/login)
- [✅] 만료 시간 설정 (JWT_EXPIRE_MINUTES 환경변수, 기본 30분)
- [✅] 토큰 리프레시 메커니즘 (/api/auth/refresh, Authorization Bearer 혹은 body.refresh_token 허용)
- [✅] 역할 기반 접근 제어 (RBAC) — require_min_rank 의존성 및 /api/rbac/premium, /api/rbac/vip 데모로 검증
- [✅] VIP/PREMIUM/STANDARD 등급별 권한 — 서비스의 check_rank_access 적용 및 테스트 보강 완료

### 다음 단계(추가 — 2025-08-15)
- [✅] Redis 키 전략/멱등키 설계 반영(구매 API/서비스 레벨)
- [✅] DB 스키마 도출 및 Alembic 마이그레이션 초안 작성(테이블/인덱스/제약) *(기존 20250813/20250815 리비전 집합 활용 – 신규 초안 불필요 판단)*
- [✅] 문서 보강: Admin/Shop 예시 페이로드/응답 및 reason 코드 표 추가, FE 연동 가이드 업데이트


- [❌] 테스트 코드(Pytest) 및 에러/로깅/문서화
  - 체크 방법: pytest -v 실행, 코드 커버리지 확인
  - 검증 기준: 핵심 기능 80% 이상 테스트 커버리지, 예외 처리 문서화
  - 체크 대상:
- [❌] 단위 테스트 (서비스, 리포지토리)
- [❌] 통합 테스트 (API 엔드포인트)
- [❌] 로깅 설정 (구조화된 로그)
- [❌] 에러 핸들링 미들웨어
- [❌] 사용자 정의 예외 클래스
- [❌] API 문서화 (OpenAPI/Swagger)


### 사용자 여정 1: 진입 및 등록
- [✅] 초대코드 유효성 검증 API (/api/invite/validate)
  - 체크 방법: 유효/만료/존재하지 않는 코드로 API 호출 
  - 검증 기준: 적절한 HTTP 상태 코드와 응답 메시지 반환 
  - 체크 대상: 코드는 고정값 5858 ✅ 테스트 완료 - 무한재사용 구현됨
- [✅] 유효성 검사 로직 — 다양한 케이스(유효/만료/사용초과/미존재) 테스트로 검증
- [✅] 만료 시간 검사 — expires_at 기준 비교로 동작 확인
- [✅] 사용 횟수 제한 검사 — None=무제한, 정수=남은횟수 계산 로직 검증
- [⚠️] 코드 보안 (예측 불가능성) — DEFAULT_INVITE_CODE 난수화 권장(운영 시 고정값 금지)
- [✅] 응답 포맷 (is_valid/error_message/code/expires_at/remaining_uses) — OpenAPI와 일치 검증
- 메모(2025-08-11): pytest.ini가 app/tests만 인식하므로 backend/tests 하 초대코드 테스트는 무시됨. app/tests/test_invite_validate.py 추가 필요. 또한 InviteCode 모델에 expires_at/max_uses/used_count 필드가 누락된 구현이 존재(simple_auth_models 등); 실제 DB/마이그레이션과 정합성 재검증 필요.

- [✅] 회원가입 API (POST /api/auth/signup)
  - 체크 방법: 유효한 초대코드와 닉네임으로 회원가입 시도
  - 검증 기준: 성공 시 사용자 생성 및 JWT 토큰 발급, 중복/오류 시 적절한 오류 응답 됨
- 체크 대상:
- [✅] 필수 필드 유효성 검사 (site_id, nickname, phone_number?, password, invite_code)
- [✅] 닉네임/아이디 중복 검사
- [✅] 초대코드 사용 처리 (현재 5858 고정 허용/무한재사용)
- [✅] 비밀번호 해싱(bcrypt)
- [❌] 초기 사용자 설정 (기본 등급/VIP/토큰 초기값 등 일부 값은 모델기본값,  정책 합의 필요)


- [✅] 회원가입 후 토큰 발급
- [✅] 로그인 API (POST /api/auth/login)
  - 체크 방법: 올바른/잘못된 site_id와 비밀번호로 로그인 시도
  - 검증/서비스에  기준: 인증 성공 시 JWT 토큰 발급, 실패 시 401 오류 
  - 체크 대상:
- [✅] 인증 로직 (site_id + password 기반)
- [✅] 로그인 시도 횟수 제한(락아웃): 최근 실패 5회 시 10분간 429 응답 (env: LOGIN_MAX_FAILED_ATTEMPTS, LOGIN_LOCKOUT_MINUTES)
- [✅] 최근 로그인 시간 업데이트
- [✅] 액세스 토큰 발급 (HS256, 만료는 환경변수 JWT_EXPIRE_MINUTES, 기본 30분)
- [✅] 리프레시 토큰 저장소 (DB) — 로그인/회원가입 시 refresh_token 발급 및 저장, /api/auth/refresh에서 검증/회전, /api/auth/logout(-all)에서 폐기
- [✅] 사용자 정보 응답 별칭 (GET /api/auth/me) — `/api/users/profile`과 동치

[✅] JWT 토큰 발급/갱신 API
  - 체크 방법: 만료된 토큰으로 갱신 요청, 유효한 토큰으로 보호된 API 접근
  - 검증 기준: 토큰 만료/갱신 메커니즘이 정상 작동 
  - 체크 대상:- [✅] 토큰 갱신 엔드포인트 (POST /api/auth/refresh) — Authorization Bearer 또는 { refresh_token } 본문 허용, 응답에 신규 access_token 반환
  - [✅] 유효기간 설정 — 환경변수 JWT_EXPIRE_MINUTES (기본 30분)
    - [✅] 토큰 블랙리스트 (구현 완료)
  - [✅] 토큰 검증 로직 (python-jose)
    - [✅] 동시 세션 관리 (구현 완료)
    - [✅] 강제 로그아웃 기능 (구현 완료)

- [✅] 사용자 정보 조회 API (GET /api/auth/me)
  - 체크 방법: JWT 토큰으로 보호된 엔드포인트 접근
  - 검증 기준: 유효한 토큰으로 사용자 정보 반환, 무효한 토큰은 401 오류 
  - 비고: `/api/users/profile`과 데이터 동치. 테스트로 상호 일치 확인.

    
### 사용자 여정 2: 메인 루프
- [✅] 프로필 조회 API (GET /api/users/profile, GET /api/auth/me; 타인: GET /api/users/{user_id})
  - 체크 방법: 자신/타인의 프로필 조회 시도, 인증 토큰 없이 접근 시도
  - 검증 기준: 본인 정보는 상세 조회, 타인 정보는 제한적 조회 또는 차단
  - 현재 상태: OpenAPI 기준으로 self 엔드포인트는 `/api/users/profile`이며, `/api/users/{id}/profile`는 노출되지 않음. `GET /api/auth/me`는 self와 동치. 타인 조회는 `GET /api/users/{user_id}`로 제한 정보 제공.
  - 체크 대상:
    - [✅] 권한 기반 정보 필터링 (본인/타인 구분 로직 구현)
    - [✅] 기본 사용자 정보 조회 (닉네임, 토큰, 랭크)
  - [✅] 활동 통계 계산 (/api/users/stats 집계 구현 완료)
  - [✅] 진행 중인 미션정보 (/api/missions, 인증 사용자 기준 목록/보상 수령 연동)
    - [✅] 보유 토큰/통화 정보 (사이버 토큰 조회 완료)
  - 완료된 작업:
    -  backend/app/routers/users.py: 프로필 API 구현 (Raw SQL 사용)
    -  권한별 데이터 필터링 로직 (본인/타인 구분)
    -  기본 사용자 정보 조회 (ID, 닉네임, 토큰, 랭크)
    -  프론트엔드 컴포넌트 정리 (중복 제거, ProfileHeader 통합)
    -  API 응답 구조 정의 및 테스트 완료
  - 테스트 결과:
    -  GET /api/users/profile → 200 OK (self)
    -  GET /api/auth/me → 200 OK (self와 동치)
    -  GET /api/users/{user_id} → 200 OK (타인 제한 정보), 무인증 접근 시 401

    -  중복 컴포넌트 정리 (ModernProfileHeader 제거)
  - 향후 개선사항:
    - [✅] 상세 활동 통계 계산 구현 (/api/users/stats: UserAction/GameStats 집계 기반)
    - [✅]  미션 진행도 API 연동 (/api/missions, /api/missions/{id}/claim에 인증 연동)
    - [✅] 타인 프로필 조회 시 제한적 정보 필터링 (PublicUserResponse 스키마 도입)
    - [✅] 인증 토큰 기반 접근 제어 강화 (missions 라우터에 get_current_user 적용)

    구현 포인트:
    - backend/app/services/user_service.py: get_user_stats 고도화(집계 계산, win_rate 등)
    - backend/app/routers/missions.py: 하드코딩된 user_id 제거→get_current_user로 교체
    - backend/app/schemas/user.py: PublicUserResponse 추가(타인 제한 정보)
    - backend/app/routers/users.py: GET /api/users/{user_id} 응답을 UserResponse|PublicUserResponse로 분기


- [✅] 슬롯 게임 API (POST /api/actions/SLOT_SPIN)
  - 체크 방법: 연속 스핀 시도, 확률 분포 검증을 위한 대량 요청 테스트
  - 검증 기준: 스트릭 카운트 증가, 변동 비율 보상 로직 정상 동작
  - 체크 대상:
  - [✅] 슬롯 스핀 확률 테이블 (app.core.config.settings.SLOT_SYMBOL_WEIGHTS로 외부화)
  - [✅] 스트릭/연속 보상 메커니즘 (Redis streak 카운터 + 승리 보너스 최대 +20%, ±5% 변동)
  - [✅] 결과 결정 알고리즘 (심볼 가중치 기반 3릴 + 페어/트리플 승리 판정)
  - [✅] 랜덤 생성기 품질 (Python random 사용; CI 시드 고정 검토)
  - [✅] 보상 지급 연동 (베팅 차감/승리금 반영)
  - [✅] 사용자 액션 로깅 (SLOT_SPIN, streak 포함)

- 추가 테스트:
- [✅] test_slot_distribution_sanity.py (300회 샘플 분포 및 평균 승리 추세 스모크)

- [✅]가챠 스핀 API (POST /api/games/gacha/pull)
- 체크 방법: 다양한 등급의 아이템 드롭 확률 테스트 (1000회 이상 시뮬레이션)
- 검증 기준: 확률 분포가 설정값의 ±5% 이내, 로그 정확히 기록
- 체크 대상:
- [✅] 등급별 아이템 확률 테이블 (Legendary/Epic/Rare/Common + Near_Miss 변형; service DEFAULT_RARITY_TABLE 및 환경변수 오버라이드)
- [✅] 천장/보장 메커니즘 (90회 실패 시 Epic 보장, animation_type=pity)
- [✅] 가챠 비용 차감 로직 (1뽑 50, 10뽑 450 할인)
- [✅] 아이템 지급 로직 (near_miss 매핑 후 실제 rarity로 지급)
- [✅] 확률 공개 정보 (/api/games/gacha/config)
- [✅] 가챠 결과 히스토리 (/api/games/gacha/stats + UserAction 로그에 결과/연출 기록)
- 테스트 허용오차: ±5% (테스트 내 random.seed 고정)

 [⚠️] 보상 지급 API (POST /api/rewards)
 - 체크 방법: 다양한 보상 유형 지급 테스트, 동시 다수 요청 처리 테스트
 - 검증 기준: 사용자 잔액/인벤토리 정확히 업데이트, 중복 지급 방지
 - 체크 대상:
- [✅] 보상 유형별 처리 (코인, 젬, 아이템) — TOKEN/COIN 통화 반영, ITEM 기록
- [✅] 트랜잭션 처리 (원자성) — Reward + UserReward 동시 커밋, 오류 시 롤백
- [✅] 중복 지급 방지 (idempotency) — UserAction(REWARD_GRANT + idempotency_key)로 재시도 안전
- [✅] 보상 히스토리 기록 — GET /api/rewards/users/{user_id}/rewards 페이지네이션, claimed_at 기준 정렬\
- [⚠️] 특별 보상 처리 (이벤트, 프로모션) — 범위 확장 시 추가 모델링 예정
- [✅] 알림 연동 (보상 지급 알림) — WebSocket best-effort 개인 알림 전송

검증 메모(2025-08-12):
- app/tests/test_rewards_distribution.py 2건 PASS. 목록 API는 UserReward↔Reward 조인으로 RewardItem(reward_id, reward_type, reward_value, awarded_at=claimed_at) 형태 반환하도록 수정.


### (2025-08-16) 변경 요약 / 세션 & 실시간 토큰
#### 변경 요약
- GameSession 테이블 추가(Alembic: 20250816_add_game_sessions_table) 및 인덱스.
- /api/games/session/start,end 영속화 (중복 409, 종료 시 total_* 업데이트) + /session/active.
- GameHistory SESSION_START/END 로깅.
- WebSocket: game_session 이벤트 확장(external_session_id 포함) + token_update 이벤트 신설(TokenService hook).

#### 검증 결과
- 코드 기준 라우터 중복 제거, 모델 필드 정합성(외부 UUID ↔ 내부 int PK) 확보.
- token_service 경로 add/deduct 시 비동기 token_update 브로드캐스트 트리거(루프 존재 시).
- 마이그레이션 실행 후 heads 단일성/인덱스 적용 필요 (alembic upgrade head 예정).

#### 다음 단계
1. pytest: 세션 시작/중복/종료/active/token_update 이벤트 수신 테스트.
2. token_update payload balance_coin/gem 분리 및 history_id 포함 여부 확장 검토.
3. 세션 내 라운드별 BET/WIN 자동 누적 및 ROI/리더보드 후속.

### 진행상황 체크리스트
- [✅] **Alembic 마이그레이션 충돌 해결** (테이블 중복, 컬럼 충돌 등)
- [✅] 기존 테이블 중복(OperationalError) 해결
- [✅] 마이그레이션 히스토리 정리 및 초기화
- [✅] 스키마 정합성 검증

- [✅] **롤백/다운그레이드 정상 동작** (운영/테스트 환경 모두)
- [✅] PostgreSQL 환경에서 롤백 테스트 (downgrade -1 → upgrade 왕복 성공)
- [✅] SQLite 제약조건 우회 방안 (일부 롤백 불가, 테이블 recreate/백업 권장)
- [✅] 안전한 롤백 전략 문서화 (초안 추가 아래 참고)

- [✅] **마이그레이션 의존성/순서 정합성 확보**
- [✅] 마이그레이션 체인 검증 (alembic current/head 단일, history 점검)
- [✅] FK/제약조건 순서 정리 (일부 점검 필요)
- [✅] 의존성 그래프 문서화 (초안 추가 아래 참고)

- [✅] **운영/테스트 DB 환경 분리** 및 .env/컨테이너 분리
- [✅] .env.test 생성 (테스트 DB/시크릿 분리)
- [✅] docker-compose.test.yml로 테스트 DB 격리 기동 검증
- [✅] CI에서 .env.test 사용하여 alembic+pytest 실행 (GitHub Actions 추가)

- [✅] **Kafka/Zookeeper 컨테이너 정상 기동** 
- (docker-compose, 네트워크, 포트, 네임 충돌 해결)
- [⚠️] **FastAPI Kafka 연동** (aiokafka/kafka-python 연결 설정, 
- 실제 Producer/Consumer 연동) — Producer OK, Consumer pending
- 소비자 초기화 개선: 파티션 assignment 대기 후 seek-to-beginning 적용 메시지 유실 방지), 
  pytest 실행 시 thread 기반 소비자 강제 및 고유 consumer group 사용
- 프로듀서 전송 확인: 동기 전송(future.get) 및 메타데이터 로그(topic/partition/offset) 출력 추가
- [✅] **Kafka 연동 자동화 테스트/문서화** (pytest 통합 테스트, 운영/테스트 환경 분리)

### 작업 체크리스트
- [✅] backend/requirements.txt에 aiokafka(or kafka-python) 추가 (kafka-python/aiokafka 이미 포함)
- [✅] 설정: app.core.config.settings에 Kafka 설정 키 정의 (KAFKA_BOOTSTRAP_SERVERS, KAFKA_ENABLED)
- [✅] 서비스: KafkaProducer/KafkaConsumer 래퍼 모듈 1개만 사용 (app/kafka_client.py 재사용)
- [✅] 엔드포인트: /api/kafka/produce, /api/kafka/health 추가 (app/routers/kafka_api.py)
- [✅] pytest 통합 테스트: 브로커 없으면 skip (app/tests/test_kafka_integration.py)
- [✅] 라운드트립 테스트 추가(app/tests/test_kafka_roundtrip.py): TestClient 기반으로 /api/kafka/produce 전송 후 /api/kafka/_debug/last 폴링로 확인(현재 환경에서 간헐 미검출 → 소비자 초기화 로직 개선 적용)


### 1. 백엔드 (Backend)
#### 핵심 인프라
- [✅] FastAPI 프로젝트 초기화 및 구조화 (routers, services, repositories, schemas/models)
- 체크 방법: 컨테이너에서 서버 기동 시 /docs 엔드포인트 정상 노출 확인
- 검증 기준: 프로젝트 구조가 Clean Architecture 원칙을 따름
- 체크 대상: (검증 결과)
- [✅] 프로젝트 디렉토리 구조 (routers/, services/, repositories/, schemas/, models/ 등) 존재
- [✅] main.py 엔트리 포인트 존재 및 라우터 포함/미들웨어 설정
- [✅] config.py (app/core/config.py)와 docker-compose(.env.test 포함)로 환경 설정 일원화
- [✅] middleware 설정 (SimpleLoggingMiddleware, CORS) 적용, 커스텀 에러 핸들러는 보류
- [✅] 의존성 주입 설정 (get_db 등 DI 패턴 사용 가능; 라우터에서 Depends 활용)
- [✅] API 문서화 설정 (Swagger /docs, /redoc 경로 활성)
- [✅] PostgreSQL 연동 및 SQLAlchemy ORM 설정 (구조/연결/세션/엔진 정상)
- 체크 방법: alembic upgrade head 실행 및 DB 연결 테스트
- 검증 기준: 모델 CRUD 작업이 오류 없이 수행됨
- 체크 대상:
- [✅] database.py 설정 파일 (엔진/세션, Postgres/SQLite fallback)
- [✅] SQLAlchemy Base 및 SessionLocal 관리 (app.database.Base)
- [✅] 환경 변수: POSTGRES_* / DATABASE_URL 지원 (compose.test에서 주입)
- [✅] 연결 옵션/echo 설정 및 연결 성공 로그 출력
- [✅] 트랜잭션 스코프(get_db DI) 제공
- [✅] 기본 모델 클래스는 각 모델 모듈에서 Base 상속으로 일관 사용
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨


- [✅] Alembic 마이그레이션 구성 및 적용 (구성/경로/스크립트/메타데이터연동정상)
- 체크 방법: alembic revision --autogenerate 명령으로 새 마이그레이션 생성
- 검증 기준: 테이블 스키마 변경이 올바르게 적용됨
- 체크 대상:
- [✅] alembic.ini 설정 파일 존재
- [✅] migrations(versions/) 구성 및 리비전 다수 존재, 단일 head 유지
- [✅] env.py: app.models.Base 메타데이터 사용, POSTGRES_* 환경에서 URL구성
- [✅] 초기/후속 마이그레이션 스크립트 존재(merge 포함) 및 순서 정합
- [✅] 롤백 지원: Postgres에서 downgrade/upgrade 왕복 검증 완료(로그참조), 
  - SQLite 제한은 문서화
- [✅] 의존성 순서 점검 및 merge로 단일 head 유지(f79d04ea1016 이후 head=20250810_align_users)
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨
  - [참고] SQLite 환경에서 롤백(downgrade) 불가(OperationalError: NOT NULL 컬럼 추가 불가) → 개발 환경에서는 recreate/백업 전략 병행 필요
  - 마이그레이션 체인/의존성 순서는 정상이나, 다운그레이드 시 DBMS별 제약(특히 SQLite)로 일부 롤백 불가
  - [✅] 운영 DB(PostgreSQL) 실전 검증 완료: 마이그레이션/롤백/의존성 순서 정상 동작 확인(테스트 스택 기준)


### DB 인프라 개선/정합성 체크리스트

- ✅ Alembic 마이그레이션 충돌 해결 (테이블 중복, 컬럼 충돌 등)
- ✅ 롤백/다운그레이드 정상 동작 (운영/테스트 환경 모두)
- ✅ 마이그레이션 의존성/순서 정합성 확보
- ✅ 운영/테스트 DB 환경 분리 및 .env/컨테이너 분리
- ❌ 주요 테이블/인덱스/제약조건 설계 확정
- ✅ 트랜잭션/원자성/정합성 테스트
- ✅ 데이터 정합성 검증(샘플 데이터, CRUD, FK 등) — 기본 CRUD/FK 스모크 통과
- ⚠️ 백업/복구 전략 수립 및 테스트
- 메모: 컨테이너 내부 덤프/복구 스니펫
- 백업: `docker exec cc_postgres pg_dump -U cc_user -d cc_webapp > backup_cc_webapp_$(Get-Date -Format yyyyMMddHHmmss).sql`
- 복구(주의: 데이터 삭제): `docker exec -i cc_postgres psql -U cc_user -d cc_webapp < backup.sql`
- ✅ 마이그레이션/정합성 자동화 테스트 스크립트 작성 — CI Alembic history + downgrade(-1)/upgrade head 추가
- ✅ 개선/이슈/해결내역 문서화
- ✅ Kafka 연동 (이벤트/실시간 데이터 처리) — 최소 연결/라운드트립(피크) 스모크 완료
- 체크 방법: Producer/Consumer 테스트, 메시지 발행/구독 확인
- 검증 기준: 메시지 손실 없이 전달되는지 확인
- 체크 대상:
- ✅ Kafka 연결 설정
- ✅ 토픽 정의 및 생성 — auto-create + CI KAFKA_TEST_TOPIC=cc_test_ci
- ✅ Producer 구현 (사용자 행동, 보상 이벤트 등)
- ✅ Consumer 그룹 설정 — 고유 consumer group/pytest 격리
- ✅ 오류 처리 및 재시도 메커니즘
- ❌ 스키마 레지스트리 연동 (필요시)

### 다음 단계(2025-08-11)
- [✅] app/tests/test_invite_validate_api.py 작성 및 통과: 유효/만료/사용초과/미존재 코드 케이스 + 응답 포맷 검증
- [✅] InviteCode 모델↔DB 스키마 정합성 정리: expires_at/max_uses/used_count/created_by 필드 통일, Alembic 보강
- [✅] 라우터 최소 등급 의존성(require_min_rank) 구현 및 데모 엔드포인트 적용(+403/200 테스트)
- [⚠️] 백업/복구 스크립트(ps1) 및 간단 Runbook 섹션 추가

- [❌] JWT 인증 및 권한 관리 (초대코드/닉네임 기반, VIP/등급별 접근제어)
  - 체크 방법: 토큰 발급/검증 테스트, 보호된 엔드포인트 접근 시도
  - 검증 기준: 인증 헤더 없이 접근 시 401, 권한 없는 경우 403 반환
  - 체크 대상:
- [✅] JWT 인코딩/디코딩 기능 (AuthService.create_access_token/verify_token 구현, 테스트 통과)
- [✅] 토큰 발급 엔드포인트 (/api/auth/signup, /api/auth/login, /api/auth/admin/login)
- [✅] 만료 시간 설정 (JWT_EXPIRE_MINUTES 환경변수, 기본 30분)
- [✅] 토큰 리프레시 메커니즘 (/api/auth/refresh, Authorization Bearer 혹은 body.refresh_token 허용)
- [✅] 역할 기반 접근 제어 (RBAC) — require_min_rank 의존성 및 /api/rbac/premium, /api/rbac/vip 데모로 검증
- [✅] VIP/PREMIUM/STANDARD 등급별 권한 — 서비스의 check_rank_access 적용 및 테스트 보강 완료

### 다음 단계(추가 — 2025-08-15)
- [✅] Redis 키 전략/멱등키 설계 반영(구매 API/서비스 레벨)
- [✅] DB 스키마 도출 및 Alembic 마이그레이션 초안 작성(테이블/인덱스/제약) *(기존 20250813/20250815 리비전 집합 활용 – 신규 초안 불필요 판단)*
- [✅] 문서 보강: Admin/Shop 예시 페이로드/응답 및 reason 코드 표 추가, FE 연동 가이드 업데이트


- [❌] 테스트 코드(Pytest) 및 에러/로깅/문서화
  - 체크 방법: pytest -v 실행, 코드 커버리지 확인
  - 검증 기준: 핵심 기능 80% 이상 테스트 커버리지, 예외 처리 문서화
  - 체크 대상:
- [❌] 단위 테스트 (서비스, 리포지토리)
- [❌] 통합 테스트 (API 엔드포인트)
- [❌] 로깅 설정 (구조화된 로그)
- [❌] 에러 핸들링 미들웨어
- [❌] 사용자 정의 예외 클래스
- [❌] API 문서화 (OpenAPI/Swagger)


### 사용자 여정 1: 진입 및 등록
- [✅] 초대코드 유효성 검증 API (/api/invite/validate)
  - 체크 방법: 유효/만료/존재하지 않는 코드로 API 호출 
  - 검증 기준: 적절한 HTTP 상태 코드와 응답 메시지 반환 
  - 체크 대상: 코드는 고정값 5858 ✅ 테스트 완료 - 무한재사용 구현됨
- [✅] 유효성 검사 로직 — 다양한 케이스(유효/만료/사용초과/미존재) 테스트로 검증
- [✅] 만료 시간 검사 — expires_at 기준 비교로 동작 확인
- [✅] 사용 횟수 제한 검사 — None=무제한, 정수=남은횟수 계산 로직 검증
- [⚠️] 코드 보안 (예측 불가능성) — DEFAULT_INVITE_CODE 난수화 권장(운영 시 고정값 금지)
- [✅] 응답 포맷 (is_valid/error_message/code/expires_at/remaining_uses) — OpenAPI와 일치 검증
- 메모(2025-08-11): pytest.ini가 app/tests만 인식하므로 backend/tests 하 초대코드 테스트는 무시됨. app/tests/test_invite_validate.py 추가 필요. 또한 InviteCode 모델에 expires_at/max_uses/used_count 필드가 누락된 구현이 존재(simple_auth_models 등); 실제 DB/마이그레이션과 정합성 재검증 필요.

- [✅] 회원가입 API (POST /api/auth/signup)
  - 체크 방법: 유효한 초대코드와 닉네임으로 회원가입 시도
  - 검증 기준: 성공 시 사용자 생성 및 JWT 토큰 발급, 중복/오류 시 적절한 오류 응답 됨
- 체크 대상:
- [✅] 필수 필드 유효성 검사 (site_id, nickname, phone_number?, password, invite_code)
- [✅] 닉네임/아이디 중복 검사
- [✅] 초대코드 사용 처리 (현재 5858 고정 허용/무한재사용)
- [✅] 비밀번호 해싱(bcrypt)
- [❌] 초기 사용자 설정 (기본 등급/VIP/토큰 초기값 등 일부 값은 모델기본값,  정책 합의 필요)


- [✅] 회원가입 후 토큰 발급
- [✅] 로그인 API (POST /api/auth/login)
  - 체크 방법: 올바른/잘못된 site_id와 비밀번호로 로그인 시도
  - 검증/서비스에  기준: 인증 성공 시 JWT 토큰 발급, 실패 시 401 오류 
  - 체크 대상:
- [✅] 인증 로직 (site_id + password 기반)
- [✅] 로그인 시도 횟수 제한(락아웃): 최근 실패 5회 시 10분간 429 응답 (env: LOGIN_MAX_FAILED_ATTEMPTS, LOGIN_LOCKOUT_MINUTES)
- [✅] 최근 로그인 시간 업데이트
- [✅] 액세스 토큰 발급 (HS256, 만료는 환경변수 JWT_EXPIRE_MINUTES, 기본 30분)
- [✅] 리프레시 토큰 저장소 (DB) — 로그인/회원가입 시 refresh_token 발급 및 저장, /api/auth/refresh에서 검증/회전, /api/auth/logout(-all)에서 폐기
- [✅] 사용자 정보 응답 별칭 (GET /api/auth/me) — `/api/users/profile`과 동치

[✅] JWT 토큰 발급/갱신 API
  - 체크 방법: 만료된 토큰으로 갱신 요청, 유효한 토큰으로 보호된 API 접근
  - 검증 기준: 토큰 만료/갱신 메커니즘이 정상 작동 
  - 체크 대상:- [✅] 토큰 갱신 엔드포인트 (POST /api/auth/refresh) — Authorization Bearer 또는 { refresh_token } 본문 허용, 응답에 신규 access_token 반환
  - [✅] 유효기간 설정 — 환경변수 JWT_EXPIRE_MINUTES (기본 30분)
    - [✅] 토큰 블랙리스트 (구현 완료)
  - [✅] 토큰 검증 로직 (python-jose)
    - [✅] 동시 세션 관리 (구현 완료)
    - [✅] 강제 로그아웃 기능 (구현 완료)

- [✅] 사용자 정보 조회 API (GET /api/auth/me)
  - 체크 방법: JWT 토큰으로 보호된 엔드포인트 접근
  - 검증 기준: 유효한 토큰으로 사용자 정보 반환, 무효한 토큰은 401 오류 
  - 비고: `/api/users/profile`과 데이터 동치. 테스트로 상호 일치 확인.

    
### 사용자 여정 2: 메인 루프
- [✅] 프로필 조회 API (GET /api/users/profile, GET /api/auth/me; 타인: GET /api/users/{user_id})
  - 체크 방법: 자신/타인의 프로필 조회 시도, 인증 토큰 없이 접근 시도
  - 검증 기준: 본인 정보는 상세 조회, 타인 정보는 제한적 조회 또는 차단
  - 현재 상태: OpenAPI 기준으로 self 엔드포인트는 `/api/users/profile`이며, `/api/users/{id}/profile`는 노출되지 않음. `GET /api/auth/me`는 self와 동치. 타인 조회는 `GET /api/users/{user_id}`로 제한 정보 제공.
  - 체크 대상:
    - [✅] 권한 기반 정보 필터링 (본인/타인 구분 로직 구현)
    - [✅] 기본 사용자 정보 조회 (닉네임, 토큰, 랭크)
  - [✅] 활동 통계 계산 (/api/users/stats 집계 구현 완료)
  - [✅] 진행 중인 미션정보 (/api/missions, 인증 사용자 기준 목록/보상 수령 연동)
    - [✅] 보유 토큰/통화 정보 (사이버 토큰 조회 완료)
  - 완료된 작업:
    -  backend/app/routers/users.py: 프로필 API 구현 (Raw SQL 사용)
    -  권한별 데이터 필터링 로직 (본인/타인 구분)
    -  기본 사용자 정보 조회 (ID, 닉네임, 토큰, 랭크)
    -  프론트엔드 컴포넌트 정리 (중복 제거, ProfileHeader 통합)
    -  API 응답 구조 정의 및 테스트 완료
  - 테스트 결과:
    -  GET /api/users/profile → 200 OK (self)
    -  GET /api/auth/me → 200 OK (self와 동치)
    -  GET /api/users/{user_id} → 200 OK (타인 제한 정보), 무인증 접근 시 401

    -  중복 컴포넌트 정리 (ModernProfileHeader 제거)
  - 향후 개선사항:
    - [✅] 상세 활동 통계 계산 구현 (/api/users/stats: UserAction/GameStats 집계 기반)
    - [✅]  미션 진행도 API 연동 (/api/missions, /api/missions/{id}/claim에 인증 연동)
    - [✅] 타인 프로필 조회 시 제한적 정보 필터링 (PublicUserResponse 스키마 도입)
    - [✅] 인증 토큰 기반 접근 제어 강화 (missions 라우터에 get_current_user 적용)

    구현 포인트:
    - backend/app/services/user_service.py: get_user_stats 고도화(집계 계산, win_rate 등)
    - backend/app/routers/missions.py: 하드코딩된 user_id 제거→get_current_user로 교체
    - backend/app/schemas/user.py: PublicUserResponse 추가(타인 제한 정보)
    - backend/app/routers/users.py: GET /api/users/{user_id} 응답을 UserResponse|PublicUserResponse로 분기


- [✅] 슬롯 게임 API (POST /api/actions/SLOT_SPIN)
  - 체크 방법: 연속 스핀 시도, 확률 분포 검증을 위한 대량 요청 테스트
  - 검증 기준: 스트릭 카운트 증가, 변동 비율 보상 로직 정상 동작
  - 체크 대상:
  - [✅] 슬롯 스핀 확률 테이블 (app.core.config.settings.SLOT_SYMBOL_WEIGHTS로 외부화)
  - [✅] 스트릭/연속 보상 메커니즘 (Redis streak 카운터 + 승리 보너스 최대 +20%, ±5% 변동)
  - [✅] 결과 결정 알고리즘 (심볼 가중치 기반 3릴 + 페어/트리플 승리 판정)
  - [✅] 랜덤 생성기 품질 (Python random 사용; CI 시드 고정 검토)
  - [✅] 보상 지급 연동 (베팅 차감/승리금 반영)
  - [✅] 사용자 액션 로깅 (SLOT_SPIN, streak 포함)

- 추가 테스트:
- [✅] test_slot_distribution_sanity.py (300회 샘플 분포 및 평균 승리 추세 스모크)

- [✅]가챠 스핀 API (POST /api/games/gacha/pull)
- 체크 방법: 다양한 등급의 아이템 드롭 확률 테스트 (1000회 이상 시뮬레이션)
- 검증 기준: 확률 분포가 설정값의 ±5% 이내, 로그 정확히 기록
- 체크 대상:
- [✅] 등급별 아이템 확률 테이블 (Legendary/Epic/Rare/Common + Near_Miss 변형; service DEFAULT_RARITY_TABLE 및 환경변수 오버라이드)
- [✅] 천장/보장 메커니즘 (90회 실패 시 Epic 보장, animation_type=pity)
- [✅] 가챠 비용 차감 로직 (1뽑 50, 10뽑 450 할인)
- [✅] 아이템 지급 로직 (near_miss 매핑 후 실제 rarity로 지급)
- [✅] 확률 공개 정보 (/api/games/gacha/config)
- [✅] 가챠 결과 히스토리 (/api/games/gacha/stats + UserAction 로그에 결과/연출 기록)
- 테스트 허용오차: ±5% (테스트 내 random.seed 고정)

 [⚠️] 보상 지급 API (POST /api/rewards)
 - 체크 방법: 다양한 보상 유형 지급 테스트, 동시 다수 요청 처리 테스트
 - 검증 기준: 사용자 잔액/인벤토리 정확히 업데이트, 중복 지급 방지
 - 체크 대상:
- [✅] 보상 유형별 처리 (코인, 젬, 아이템) — TOKEN/COIN 통화 반영, ITEM 기록
- [✅] 트랜잭션 처리 (원자성) — Reward + UserReward 동시 커밋, 오류 시 롤백
- [✅] 중복 지급 방지 (idempotency) — UserAction(REWARD_GRANT + idempotency_key)로 재시도 안전
- [✅] 보상 히스토리 기록 — GET /api/rewards/users/{user_id}/rewards 페이지네이션, claimed_at 기준 정렬\
- [⚠️] 특별 보상 처리 (이벤트, 프로모션) — 범위 확장 시 추가 모델링 예정
- [✅] 알림 연동 (보상 지급 알림) — WebSocket best-effort 개인 알림 전송

검증 메모(2025-08-12):
- app/tests/test_rewards_distribution.py 2건 PASS. 목록 API는 UserReward↔Reward 조인으로 RewardItem(reward_id, reward_type, reward_value, awarded_at=claimed_at) 형태 반환하도록 수정.


### (2025-08-16) 변경 요약 / 세션 & 실시간 토큰
#### 변경 요약
- GameSession 테이블 추가(Alembic: 20250816_add_game_sessions_table) 및 인덱스.
- /api/games/session/start,end 영속화 (중복 409, 종료 시 total_* 업데이트) + /session/active.
- GameHistory SESSION_START/END 로깅.
- WebSocket: game_session 이벤트 확장(external_session_id 포함) + token_update 이벤트 신설(TokenService hook).

#### 검증 결과
- 코드 기준 라우터 중복 제거, 모델 필드 정합성(외부 UUID ↔ 내부 int PK) 확보.
- token_service 경로 add/deduct 시 비동기 token_update 브로드캐스트 트리거(루프 존재 시).
- 마이그레이션 실행 후 heads 단일성/인덱스 적용 필요 (alembic upgrade head 예정).

#### 다음 단계
1. pytest: 세션 시작/중복/종료/active/token_update 이벤트 수신 테스트.
2. token_update payload balance_coin/gem 분리 및 history_id 포함 여부 확장 검토.
3. 세션 내 라운드별 BET/WIN 자동 누적 및 ROI/리더보드 후속.

### 진행상황 체크리스트
- [✅] **Alembic 마이그레이션 충돌 해결** (테이블 중복, 컬럼 충돌 등)
- [✅] 기존 테이블 중복(OperationalError) 해결
- [✅] 마이그레이션 히스토리 정리 및 초기화
- [✅] 스키마 정합성 검증

- [✅] **롤백/다운그레이드 정상 동작** (운영/테스트 환경 모두)
- [✅] PostgreSQL 환경에서 롤백 테스트 (downgrade -1 → upgrade 왕복 성공)
- [✅] SQLite 제약조건 우회 방안 (일부 롤백 불가, 테이블 recreate/백업 권장)
- [✅] 안전한 롤백 전략 문서화 (초안 추가 아래 참고)

- [✅] **마이그레이션 의존성/순서 정합성 확보**
- [✅] 마이그레이션 체인 검증 (alembic current/head 단일, history 점검)
- [✅] FK/제약조건 순서 정리 (일부 점검 필요)
- [✅] 의존성 그래프 문서화 (초안 추가 아래 참고)

- [✅] **운영/테스트 DB 환경 분리** 및 .env/컨테이너 분리
- [✅] .env.test 생성 (테스트 DB/시크릿 분리)
- [✅] docker-compose.test.yml로 테스트 DB 격리 기동 검증
- [✅] CI에서 .env.test 사용하여 alembic+pytest 실행 (GitHub Actions 추가)

- [✅] **Kafka/Zookeeper 컨테이너 정상 기동** 
- (docker-compose, 네트워크, 포트, 네임 충돌 해결)
- [⚠️] **FastAPI Kafka 연동** (aiokafka/kafka-python 연결 설정, 
- 실제 Producer/Consumer 연동) — Producer OK, Consumer pending
- 소비자 초기화 개선: 파티션 assignment 대기 후 seek-to-beginning 적용 메시지 유실 방지), 
  pytest 실행 시 thread 기반 소비자 강제 및 고유 consumer group 사용
- 프로듀서 전송 확인: 동기 전송(future.get) 및 메타데이터 로그(topic/partition/offset) 출력 추가
- [✅] **Kafka 연동 자동화 테스트/문서화** (pytest 통합 테스트, 운영/테스트 환경 분리)

### 작업 체크리스트
- [✅] backend/requirements.txt에 aiokafka(or kafka-python) 추가 (kafka-python/aiokafka 이미 포함)
- [✅] 설정: app.core.config.settings에 Kafka 설정 키 정의 (KAFKA_BOOTSTRAP_SERVERS, KAFKA_ENABLED)
- [✅] 서비스: KafkaProducer/KafkaConsumer 래퍼 모듈 1개만 사용 (app/kafka_client.py 재사용)
- [✅] 엔드포인트: /api/kafka/produce, /api/kafka/health 추가 (app/routers/kafka_api.py)
- [✅] pytest 통합 테스트: 브로커 없으면 skip (app/tests/test_kafka_integration.py)
- [✅] 라운드트립 테스트 추가(app/tests/test_kafka_roundtrip.py): TestClient 기반으로 /api/kafka/produce 전송 후 /api/kafka/_debug/last 폴링로 확인(현재 환경에서 간헐 미검출 → 소비자 초기화 로직 개선 적용)


### 1. 백엔드 (Backend)
#### 핵심 인프라
- [✅] FastAPI 프로젝트 초기화 및 구조화 (routers, services, repositories, schemas/models)
- 체크 방법: 컨테이너에서 서버 기동 시 /docs 엔드포인트 정상 노출 확인
- 검증 기준: 프로젝트 구조가 Clean Architecture 원칙을 따름
- 체크 대상: (검증 결과)
- [✅] 프로젝트 디렉토리 구조 (routers/, services/, repositories/, schemas/, models/ 등) 존재
- [✅] main.py 엔트리 포인트 존재 및 라우터 포함/미들웨어 설정
- [✅] config.py (app/core/config.py)와 docker-compose(.env.test 포함)로 환경 설정 일원화
- [✅] middleware 설정 (SimpleLoggingMiddleware, CORS) 적용, 커스텀 에러 핸들러는 보류
- [✅] 의존성 주입 설정 (get_db 등 DI 패턴 사용 가능; 라우터에서 Depends 활용)
- [✅] API 문서화 설정 (Swagger /docs, /redoc 경로 활성)
- [✅] PostgreSQL 연동 및 SQLAlchemy ORM 설정 (구조/연결/세션/엔진 정상)
- 체크 방법: alembic upgrade head 실행 및 DB 연결 테스트
- 검증 기준: 모델 CRUD 작업이 오류 없이 수행됨
- 체크 대상:
- [✅] database.py 설정 파일 (엔진/세션, Postgres/SQLite fallback)
- [✅] SQLAlchemy Base 및 SessionLocal 관리 (app.database.Base)
- [✅] 환경 변수: POSTGRES_* / DATABASE_URL 지원 (compose.test에서 주입)
- [✅] 연결 옵션/echo 설정 및 연결 성공 로그 출력
- [✅] 트랜잭션 스코프(get_db DI) 제공
- [✅] 기본 모델 클래스는 각 모델 모듈에서 Base 상속으로 일관 사용
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨


- [✅] Alembic 마이그레이션 구성 및 적용 (구성/경로/스크립트/메타데이터연동정상)
- 체크 방법: alembic revision --autogenerate 명령으로 새 마이그레이션 생성
- 검증 기준: 테이블 스키마 변경이 올바르게 적용됨
- 체크 대상:
- [✅] alembic.ini 설정 파일 존재
- [✅] migrations(versions/) 구성 및 리비전 다수 존재, 단일 head 유지
- [✅] env.py: app.models.Base 메타데이터 사용, POSTGRES_* 환경에서 URL구성
- [✅] 초기/후속 마이그레이션 스크립트 존재(merge 포함) 및 순서 정합
- [✅] 롤백 지원: Postgres에서 downgrade/upgrade 왕복 검증 완료(로그참조), 
  - SQLite 제한은 문서화
- [✅] 의존성 순서 점검 및 merge로 단일 head 유지(f79d04ea1016 이후 head=20250810_align_users)
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
  - 파일명: backend/scripts/reset_db_and_alembic.sh
  - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
  - 실행 전 반드시 DB 백업 필수
  - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨
  - [참고] SQLite 환경에서 롤백(downgrade) 불가(OperationalError: NOT NULL 컬럼 추가 불가) → 개발 환경에서는 recreate/백업 전략 병행 필요
  - 마이그레이션 체인/의존성 순서는 정상이나, 다운그레이드 시 DBMS별 제약(특히 SQLite)로 일부 롤백 불가
  - [✅] 운영 DB(PostgreSQL) 실전 검증 완료: 마이그레이션/롤백/의존성 순서 정상 동작 확인(테스트 스택 기준)


### DB 인프라 개선/정합성 체크리스트

- ✅ Alembic 마이그레이션 충돌 해결 (테이블 중복, 컬럼 충돌 등)
- ✅ 롤백/다운그레이드 정상 동작 (운영/테스트 환경 모두)
- ✅ 마이그레이션 의존성/순서 정합성 확보
- ✅ 운영/테스트 DB 환경 분리 및 .env/컨테이너 분리
- ❌ 주요 테이블/인덱스/제약조건 설계 확정
- ✅ 트랜잭션/원자성/정합성 테스트
- ✅ 데이터 정합성 검증(샘플 데이터, CRUD, FK 등) — 기본 CRUD/FK 스모크 통과
- ⚠️ 백업/복구 전략 수립 및 테스트
- 메모: 컨테이너 내부 덤프/복구 스니펫
- 백업: `docker exec cc_postgres pg_dump -U cc_user -d cc_webapp > backup_cc_webapp_$(Get-Date -Format yyyyMMddHHmmss).sql`
- 복구(주의: 데이터 삭제): `docker exec -i cc_postgres psql -U cc_user -d cc_webapp < backup.sql`
- ✅ 마이그레이션/정합성 자동화 테스트 스크립트 작성 — CI Alembic history + downgrade(-1)/upgrade head 추가
- ✅ 개선/이슈/해결내역 문서화
- ✅ Kafka 연동 (이벤트/실시간 데이터 처리) — 최소 연결/라운드트립(피크) 스모크 완료
- 체크 방법: Producer/Consumer 테스트, 메시지 발행/구독 확인
- 검증 기준: 메시지 손실 없이 전달되는지 확인
- 체크 대상:
- ✅ Kafka 연결 설정
- ✅ 토픽 정의 및 생성 — auto-create + CI KAFKA_TEST_TOPIC=cc_test_ci
- ✅ Producer 구현 (사용자 행동, 보상 이벤트 등)
- ✅ Consumer 그룹 설정 — 고유 consumer group/pytest 격리
- ✅ 오류 처리 및 재시도 메커니즘
- ❌ 스키마 레지스트리 연동 (필요시)

### 다음 단계(2025-08-11)
- [✅] app/tests/test_invite_validate_api.py 작성 및 통과: 유효/만료/사용초과/미존재 코드 케이스 + 응답 포맷 검증
- [✅] InviteCode 모델↔DB 스키마 정합성 정리: expires_at/max_uses/used_count/created_by 필드 통일, Alembic 보강
- [✅] 라우터 최소 등급 의존성(require_min_rank) 구현 및 데모 엔드포인트 적용(+403/200 테스트)
- [⚠️] 백업/복구 스크립트(ps1) 및 간단 Runbook 섹션 추가

- [❌] JWT 인증 및 권한 관리 (초대코드/닉네임 기반, VIP/등급별 접근제어)
  - 체크 방법: 토큰 발급/검증 테스트, 보호된 엔드포인트 접근 시도
  - 검증 기준: 인증 헤더 없이 접근 시 401, 권한 없는 경우 403 반환
  - 체크 대상:
- [✅] JWT 인코딩/디코딩 기능 (AuthService.create_access_token/verify_token 구현, 테스트 통과)
- [✅] 토큰 발급 엔드포인트 (/api/auth/signup, /api/auth/login, /api/auth/admin/login)
- [✅] 만료 시간 설정 (JWT_EXPIRE_MINUTES 환경변수, 기본 30분)
- [✅] 토큰 리프레시 메커니즘 (/api/auth/refresh, Authorization Bearer 혹은 body.refresh_token 허용)
- [✅] 역할 기반 접근 제어 (RBAC) — require_min_rank 의존성 및 /api/rbac/premium, /api/rbac/vip 데모로 검증
- [✅] VIP/PREMIUM/STANDARD 등급별 권한 — 서비스의 check_rank_access 적용 및 테스트 보강 완료

### 다음 단계(추가 — 2025-08-15)
- [✅] Redis 키 전략/멱등키 설계 반영(구매 API/서비스 레벨)
- [✅] DB 스키마 도출 및 Alembic 마이그레이션 초안 작성(테이블/인덱스/제약) *(기존 20250813/20250815 리비전 집합 활용 – 신규 초안 불필요 판단)*
- [✅] 문서 보강: Admin/Shop 예시 페이로드/응답 및 reason 코드 표 추가, FE 연동 가이드 업데이트


- [❌] 테스트 코드(Pytest) 및 에러/로깅/문서화
  - 체크 방법: pytest -v 실행, 코드 커버리지 확인
  - 검증 기준: 핵심 기능 80% 이상 테스트 커버리지, 예외 처리 문서화
  - 체크 대상:
- [❌] 단위 테스트 (서비스, 리포지토리)
- [❌] 통합 테스트 (API 엔드포인트)
- [❌] 로깅 설정 (구조화된 로그)
- [❌] 에러 핸들링 미들웨어
- [❌] 사용자 정의 예외 클래스
- [❌] API 문서화 (OpenAPI/Swagger)


### 사용자 여정 1: 진입 및 등록
- [✅] 초대코드 유효성 검증 API (/api/invite/validate)
  - 체크 방법: 유효/만료/존재하지 않는 코드로 API 호출 
  - 검증 기준: 적절한 HTTP 상태 코드와 응답 메시지 반환 
  - 체크 대상: 코드는 고정값 5858 ✅ 테스트 완료 - 무한재사용 구현됨
- [✅] 유효성 검사 로직 — 다양한 케이스(유효/만료/사용초과/미존재) 테스트로 검증
- [✅] 만료 시간 검사 — expires_at 기준 비교로 동작 확인
- [✅] 사용 횟수 제한 검사 — None=무제한, 정수=남은횟수 계산 로직 검증
- [⚠️] 코드 보안 (예측 불가능성) — DEFAULT_INVITE_CODE 난수화 권장(운영 시 고정값 금지)
- [✅] 응답 포맷 (is_valid/error_message/code/expires_at/remaining_uses) — OpenAPI와 일치 검증
- 메모(2025-08-11): pytest.ini가 app/tests만 인식하므로 backend/tests 하 초대코드 테스트는 무시됨. app/tests/test_invite_validate.py 추가 필요. 또한 InviteCode 모델에 expires_at/max_uses/used_count 필드가 누락된 구현이 존재(simple_auth_models 등); 실제 DB/마이그레이션과 정합성 재검증 필요.

- [✅] 회원가입 API (POST /api/auth/signup)
  - 체크 방법: 유효한 초대코드와 닉네임으로 회원가입 시도
  - 검증 기준: 성공 시 사용자 생성 및 JWT 토큰 발급, 중복/오류 시 적절한 오류 응답 됨
- 체크 대상:
- [✅] 필수 필드 유효성 검사 (site_id, nickname, phone_number?, password, invite_code)
- [✅] 닉네임/아이디 중복 검사
- [✅] 초대코드 사용 처리 (현재 5858 고정 허용/무한재사용)
- [✅] 비밀번호 해싱(bcrypt)
- [❌] 초기 사용자 설정 (기본 등급/VIP/토큰 초기값 등 일부 값은 모델기본값,  정책 합의 필요)


- [✅] 회원가입 후 토큰 발급
- [✅] 로그인 API (POST /api/auth/login)
  - 체크 방법: 올바른/잘못된 site_id와 비밀번호로 로그인 시도
  - 검증/서비스에  기준: 인증 성공 시 JWT 토큰 발급, 실패 시 401 오류 
  - 체크 대상:
- [✅] 인증 로직 (site_id + password 기반)
- [✅] 로그인 시도 횟수 제한(락아웃): 최근 실패 5회 시 10분간 429 응답 (env: LOGIN_MAX_FAILED_ATTEMPTS, LOGIN_LOCKOUT_MINUTES)
- [✅] 최근 로그인 시간 업데이트
- [✅] 액세스 토큰 발급 (HS256, 만료는 환경변수 JWT_EXPIRE_MINUTES, 기본 30분)
- [✅] 리프레시 토큰 저장소 (DB) — 로그인/회원가입 시 refresh_token 발급 및 저장, /api/auth/refresh에서 검증/회전, /api/auth/logout(-all)에서 폐기
- [✅] 사용자 정보 응답 별칭 (GET /api/auth/me) — `/api/users/profile`과 동치

[✅] JWT 토큰 발급/갱신 API
  - 체크 방법: 만료된 토큰으로 갱신 요청, 유효한 토큰으로 보호된 API 접근
  - 검증 기준: 토큰 만료/갱신 메커니즘이 정상 작동 
  - 체크 대상:- [✅] 토큰 갱신 엔드포인트 (POST /api/auth/refresh) — Authorization Bearer 또는 { refresh_token } 본문 허용, 응답에 신규 access_token 반환
  - [✅] 유효기간 설정 — 환경변수 JWT_EXPIRE_MINUTES (기본 30분)
    - [✅] 토큰 블랙리스트 (구현 완료)
  - [✅] 토큰 검증 로직 (python-jose)
    - [✅] 동시 세션 관리 (구현 완료)
    - [✅] 강제 로그아웃 기능 (구현 완료)

- [✅] 사용자 정보 조회 API (GET /api/auth/me)
  - 체크 방법: JWT 토큰으로 보호된 엔드포인트 접근
  - 검증 기준: 유효한 토큰으로 사용자 정보 반환, 무효한 토큰은 401 오류 
  - 비고: `/api/users/profile`과 데이터 동치. 테스트로 상호 일치 확인.

    
### 사용자 여정 2: 메인 루프
- [✅] 프로필 조회 API (GET /api/users/profile, GET /api/auth/me; 타인: GET /api/users/{user_id})
  - 체크 방법: 자신/타인의 프로필 조회 시도, 인증 토큰 없이 접근 시도
  - 검증 기준: 본인 정보는 상세 조회, 타인 정보는 제한적 조회 또는 차단
  - 현재 상태: OpenAPI 기준으로 self 엔드포인트는 `/api/users/profile`이며, `/api/users/{id}/profile`는 노출되지 않음. `GET /api/auth/me`는 self와 동치. 타인 조회는 `GET /api/users/{user_id}`로 제한 정보 제공.
  - 체크 대상:
    - [✅] 권한 기반 정보 필터링 (본인/타인 구분 로직 구현)
    - [✅] 기본 사용자 정보 조회 (닉네임, 토큰, 랭크)
  - [✅] 활동 통계 계산 (/api/users/stats 집계 구현 완료)
  - [✅] 진행 중인 미션정보 (/api/missions, 인증 사용자 기준 목록/보상 수령 연동)
    - [✅] 보유 토큰/통화 정보 (사이버 토큰 조회 완료)
  - 완료된 작업:
    -  backend/app/routers/users.py: 프로필 API 구현 (Raw SQL 사용)
    -  권한별 데이터 필터링 로직 (본인/타인 구분)
    -  기본 사용자 정보 조회 (ID, 닉네임, 토큰, 랭크)
    -  프론트엔드 컴포넌트 정리 (중복 제거, ProfileHeader 통합)
    -  API 응답 구조 정의 및 테스트 완료
  - 테스트 결과:
    -  GET /api/users/profile → 200 OK (self)
    -  GET /api/auth/me → 200 OK (self와 동치)
    -  GET /api/users/{user_id} → 200 OK (타인 제한 정보), 무인증 접근 시 401

    -  중복 컴포넌트 정리 (ModernProfileHeader 제거)
  - 향후 개선사항:
    - [✅] 상세 활동 통계 계산 구현 (/api/users/stats: UserAction/GameStats 집계 기반)
    - [✅]  미션 진행도 API 연동 (/api/missions, /api/missions/{id}/claim에 인증 연동)
    - [✅] 타인 프로필 조회 시 제한적 정보 필터링 (PublicUserResponse 스키마 도입)
    - [✅] 인증 토큰 기반 접근 제어 강화 (missions 라우터에 get_current_user 적용)

    구현 포인트:
    - backend/app/services/user_service.py: get_user_stats 고도화(집계 계산, win_rate 등)
    - backend/app/routers/missions.py: 하드코딩된 user_id 제거→get_current_user로 교체
    - backend/app/schemas/user.py: PublicUserResponse 추가(타인 제한 정보)
    - backend/app/routers/users.py: GET /api/users/{user_id} 응답을 UserResponse|PublicUserResponse로 분기


- [✅] 슬롯 게임 API (POST /api/actions/SLOT_SPIN)
  - 체크 방법: 연속 스핀 시도, 확률 분포 검증을 위한 대량 요청 테스트
  - 검증 기준: 스트릭 카운트 증가, 변동 비율 보상 로직 정상 동작
  - 체크 대상:
  - [✅] 슬롯 스핀 확률 테이블 (app.core.config.settings.SLOT_SYMBOL_WEIGHTS로 외부화)
  - [✅] 스트릭/연속 보상 메커니즘 (Redis streak 카운터 + 승리 보너스 최대 +20%, ±5% 변동)
  - [✅] 결과 결정 알고리즘 (심볼 가중치 기반 3릴 + 페어/트리플 승리 판정)
  - [✅] 랜덤 생성기 품질 (Python random 사용; CI 시드 고정 검토)
  - [✅] 보상 지급 연동 (베팅 차감/승리금 반영)
  - [✅] 사용자 액션 로깅 (SLOT_SPIN, streak 포함)

- 추가 테스트:
- [✅] test_slot_distribution_sanity.py (300회 샘플 분포 및 평균 승리 추세 스모크)

- [✅]가챠 스핀 API (POST /api/games/gacha/pull)
- 체크 방법: 다양한 등급의 아이템 드롭 확률 테스트 (1000회 이상 시뮬레이션)
- 검증 기준: 확률 분포가 설정값의 ±5% 이내, 로그 정확히 기록
- 체크 대상:
- [✅] 등급별 아이템 확률 테이블 (Legendary/Epic/Rare/Common + Near_Miss 변형; service DEFAULT_RARITY_TABLE 및 환경변수 오버라이드)
- [✅] 천장/보장 메커니즘 (90회 실패 시 Epic 보장, animation_type=pity)
- [✅] 가챠 비용 차감 로직 (1뽑 50, 10뽑 450 할인)
- [✅] 아이템 지급 로직 (near_miss 매핑 후 실제 rarity로 지급)
- [✅] 확률 공개 정보 (/api/games/gacha/config)
- [✅] 가챠 결과 히스토리 (/api/games/gacha/stats + UserAction 로그에 결과/연출 기록)
- 테스트 허용오차: ±5% (테스트 내 random.seed 고정)

 [⚠️] 보상 지급 API (POST /api/rewards)
 - 체크 방법: 다양한 보상 유형 지급 테스트, 동시 다수 요청 처리 테스트
 - 검증 기준: 사용자 잔액/인벤토리 정확히 업데이트, 중복 지급 방지
 - 체크 대상:
- [✅] 보상 유형별 처리 (코인, 젬, 아이템) — TOKEN/COIN 통화 반영, ITEM 기록
- [✅] 트랜잭션 처리 (원자성) — Reward + UserReward 동시 커밋, 오류 시 롤백
- [✅] 중복 지급 방지 (idempotency) — UserAction(REWARD_GRANT + idempotency_key)로 재시도 안전
- [✅] 보상 히스토리 기록 — GET /api/rewards/users/{user_id}/rewards 페이지네이션, claimed_at 기준 정렬\
- [⚠️] 특별 보상 처리 (이벤트, 프로모션) — 범위 확장 시 추가 모델링 예정
- [✅] 알림 연동 (보상 지급 알림) — WebSocket best-effort 개인 알림 전송

검증 메모(2025-08-12):
- app/tests/test_rewards_distribution.py 2건 PASS. 목록 API는 UserReward↔Reward 조인으로 RewardItem(reward_id, reward_type, reward_value, awarded_at=claimed_at) 형태 반환하도록 수정.


## (2025-08-16) 세션 & 토큰 실시간 기능 업데이트
- GameSession 테이블(Alembic 20250816_add_game_sessions_table) 도입: int PK + external_session_id(UUID) unique, 인덱스(user_id+status, user_id+game_type, start_time, created_at)
- /api/games/session/start,end 영속화: 활성 중복 409, 종료 시 total_rounds/total_bet/total_win 기록
- /api/games/session/active 추가, GameHistory SESSION_START/END 로깅
- WebSocket: game_session 이벤트( start/end ) 확장 + token_update 이벤트(TokenService add/deduct hook)
- 향후 확장 예정: token_update에 history_id, balance_coin/gem 세분화, 세션 라운드 자동 누적 및 ROI

### 검증 (계획/수행)
- [ ] alembic upgrade head 후 game_sessions 존재 및 인덱스 확인(ix_game_sessions_*)