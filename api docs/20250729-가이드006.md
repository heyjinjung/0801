## 상태 업데이트 - 2025-08-13

- ✅ 실시간 알림(WS/SSE) 완성: 주제(topic) 필터링, 다중 클라이언트 브로드캐스트, 재연결 시 백필(backfill) 지원, 정상 종료/해제 처리
- ✅ 사용자 행동 로깅 API 완료: POST /api/actions, POST /api/actions/batch (PII 마스킹, DB 영속화, 선택적 Kafka 발행)
- ✅ 테스트 추가 및 실행: 실시간 알림/액션 로깅 통합 테스트 통과

### 추가 업데이트 - 2025-08-13 (Shop & Migrations)

변경 요약
- Shop 도메인 모델 추가 및 등록: ShopProduct, ShopDiscount, ShopTransaction (models/__init__.py 포함)
- Alembic 마이그레이션 추가: 
  - 20250813_user_actions_ix_type_created (user_actions(action_type, created_at|timestamp) 인덱스)
  - 20250813_create_shop_tables (shop_* 테이블 신규 생성; idempotent)
- SQLAlchemy 예약어 충돌 제거: 모델 속성명 metadata → extra로 교체
- VS Code 테스트 태스크 개선: repo 루트에서 실행 시 경로 오류 방지를 위해 shop 테스트 태스크에 cwd=backend 적용

검증
- pytest: app/tests/test_shop_buy_api.py → PASS (충전/과금 실패/정상 구매)
- 인증 스모크(초대/로그인/리프레시) 기존 케이스 영향 없음
- Alembic 체인 단일 유지: f79d04ea1016 → 20250813_user_actions_ix_type_created → 20250813_create_shop_tables

다음 단계 (체크리스트)
- ✅ 상품 카탈로그/가격 산정 API 추가: GET /api/shop/products, GET /api/shop/price/{product_id}
- ✅ 내 거래 내역 조회 API 추가: GET /api/shop/transactions (토큰 사용자 기준)
- ✅ 서버 가격 산정 사용: POST /api/shop/buy 시 compute_price 우선 적용, 클라이언트 금액 신뢰 안 함
- ✅ 거래 기록(영수증 코드 포함) 저장: ShopTransaction에 성공/실패/대기 기록
- ✅ 결제 게이트웨이 어댑터(개발용) 추가: PaymentGatewayService (env: PAYMENT_GATEWAY_MODE)
- ✅ 결제 실패/대기 처리: /api/shop/buy(gems) 선처리, failed/pending 트랜잭션 기록 및 메시지 반환
- ✅ 관리자 거래 검색/필터 API: GET /api/admin/transactions (user_id, product_id, status, 기간, receipt_code, limit)
- ✅ 환불 API(관리자): POST /api/admin/transactions/{receipt_code}/refund
- ✅ 결제 보류/정산 플로우: 사용자 정산/폴링, 웹훅, 관리자 강제 정산
- ✅ Alembic: shop_* 및 limited/promo 테이블 체인 정비 (단일 head 유지)
- ⚠️ 한정 패키지 API: 리스트/구매/관리자 업서트/긴급 비활성화 (E2E 일부 skip → 테스트 보강 필요)
- ❌ OpenAPI에 한정 패키지 엔드포인트 반영 및 문서화
- ❌ 컨테이너 내부에서 alembic upgrade head 실행 후 /docs 확인 및 필요 시 OpenAPI 재수출

검증 요약
- pytest 스모크: app/tests/test_realtime_notifications.py, app/tests/test_actions_api.py → PASS
- /docs 노출 정상, 웹소켓 연결/해제 시 정상 처리 확인, SSE Last-Event-ID 재개 동작 확인
- Alembic heads 단일 상태 유지(신규 마이그레이션 없음)

엔드포인트 요약
- WebSocket: GET /ws/notifications/{user_id}?topics=a,b
- SSE: GET /sse/notifications/{user_id}?topics=a,b&lastEventId=...
- Dev: POST /api/notifications/{user_id}/send, GET /api/notifications/{user_id}/backfill
- Actions: POST /api/actions, POST /api/actions/batch
- Shop: GET /api/shop/products, GET /api/shop/price/{product_id}, POST /api/shop/buy, GET /api/shop/transactions
  - Admin: GET /api/admin/transactions, POST /api/admin/transactions/{receipt_code}/refund
  - Shop Limited: GET /api/shop/limited-packages, POST /api/shop/buy-limited
  - Admin Limited: POST /api/admin/limited-packages/upsert, POST /api/admin/limited-packages/{package_id}/disable

추가 업데이트 (결제 보류/정산)
- 사용자 보유 거래 단일 조회: GET /api/shop/transactions/{receipt_code}
- 보류된 gems 거래 정산/폴링: POST /api/shop/transactions/{receipt_code}/settle
- PAYMENT_GATEWAY_MODE=always_success|always_fail|pending_then_success|random
  - pending_then_success 모드: 최초 결제는 pending, 약 1초 경과 후 정산(폴링) 시 success로 전환됨
 - 결제 웹훅(선택): POST /api/shop/webhook/payment { receipt_code, status } (헤더: x-webhook-secret)
 - 관리자 강제 정산(테스트/운영 대응): POST /api/admin/transactions/{receipt_code}/force-settle { outcome: success|failed }

운영 메모
- Kafka 발행은 선택적이며 실패 시 API 응답에는 영향 주지 않음(베스트 에포트)
- PII 컨텍스트 필드(email, phone 등)는 수집 전 마스킹하여 저장

다음 단계(옵션)
- user_actions 인덱스 추가: (user_id, created_at), (action_type, created_at)
- 보관/압축 정책 수립 및 주기적 아카이브 파이프라인
- 프론트엔드에서 주요 사용자 플로우에 /api/actions 연동

# Casino-Club F2P 프로젝트: 최종 체크리스트

## 2025-08-12 스모크 테스트 결과 (Windows PowerShell)

- 검증 범위: /health, /api/auth/signup, /api/auth/login, /api/users/tokens/add, /api/games/slot/spin, /api/games/gacha/pull, /api/users/profile
- 환경: docker-compose(local), 백엔드 http://localhost:8001, Windows PowerShell 5.1

### 결과 요약
- Health: 200 OK, status=healthy
- 회원가입/로그인: 200 OK (invite_code=5858), access_token 발급됨
- 토큰 보충: POST /api/users/tokens/add?amount=20000 → 200 OK
- 슬롯 스핀: POST /api/games/slot/spin { bet_amount=50 } → 200 OK, 예: { reels: ["🎰", "🎰", "7️⃣"], win_amount: 0|100, is_jackpot: false, balance: 20,150± }
- 가챠 10회: POST /api/games/gacha/pull { pull_count=10 } → 200 OK,
  - 응답 예시: items 10개, rare_item_count=0~3, ultra_rare_item_count=0~2, balance 약 3,000 감소(풀당 300로 추정)
  - message="Gacha pull completed", currency_balance.tokens 동기화 확인
- 자기 프로필: GET /api/users/profile → 200 OK, { id, site_id, nickname, phone_number, cyber_token_balance, created_at, is_active, is_admin, rank }

### Windows PowerShell 이모지(슬롯 릴) 깨짐 현상 대응
- 현상: reels에 "ð", "ï¸â" 형태의 깨진 문자가 출력됨 (예: 7️⃣ → "7ï¸â£")
- 원인: Windows PowerShell 5.1 콘솔 기본 출력 인코딩이 UTF-8이 아님
- 해결 팁:
  1) 콘솔 코드페이지/출력 인코딩을 UTF-8로 전환 후 실행
     - chcp 65001 (코드페이지 UTF-8)
     - [Console]::OutputEncoding = New-Object System.Text.UTF8Encoding $false
     - 가능하면 PowerShell 7+ 사용 권장 (기본 UTF-8)
  2) 화면 출력 대신 파일로 저장해 확인
     - ConvertTo-Json -Compress | Out-File -Encoding utf8 result.json → 에디터에서 이모지 정상 확인

### 참고 사항 / 다음 단계
- 가챠 확률/근접실패/천장/할인 적용됨
  - 천장(pity): 90회 누적 실패 시 최소 Epic 보장(animation_type=pity, 카운터 리셋)
  - 근접 실패(near-miss): 기본 17.3%를 기반으로 히스토리/연속 실패에 따라 가중, 출력은 Rare/Epic로 매핑
  - 비용: 1뽑 50, 10뽑 450(할인)
  - 응답: animation_type, psychological_message 포함; special_animation은 의미있는 상태에서 animation_type 미러링
- RNG 분포 검증(±5% 목표)용 자동화 테스트 추가 예정
- 리프레시 토큰 회전/폐기 플로우에 대한 테스트 케이스도 보강 계획

### 추가 업데이트 (2025-08-12 밤): OpenAPI·테스트·게임 설계 문서화

1) OpenAPI 재수출 및 스키마 예시(가챠 응답)
- 컨테이너 내부에서 실행:
  - python -m app.export_openapi (결과: backend/current_openapi.json 갱신)
- 가챠 응답 모델에 예시가 포함되었습니다(animation_type, psychological_message):
  - animation_type: normal|epic|legendary|near_miss|pity
  - psychological_message: 즉시 피드백용 메시지(근접 실패/전설/연속 실패 시 차등)
  - 예시(요약): { items: [...], rare_item_count: 1, ultra_rare_item_count: 1, pull_count: 10, balance: 12345, animation_type: "near_miss", psychological_message: "거의 다 왔어요! 한 번만 더 도전해보세요!", message: "Gacha pull completed", currency_balance: { tokens: 11895, gems: 0 } }

2) CI 테스트 연동 및 RNG 안정화
- 신규 테스트 2종을 CI에 포함 권장:
  - app/tests/test_gacha_distribution.py (1000 pulls 분포 검증, 현재 허용오차 ±10%)
  - app/tests/test_auth_refresh_rotate_revoke.py (리프레시 회전/폐기, logout 즉시 access 블랙리스트 확인)
- 난수 시드 권장(플레이크 완화):
  - PYTEST_ADDOPTS 환경에 --randomly-seed 또는 테스트 내 random.seed 고정 고려
  - 가챠 테스트는 서비스의 동적 near-miss/피티/히스토리 감쇠가 존재하므로 ±10% 허용오차를 유지

3) 게임 설계: 가챠 천장/근접 실패(near-miss) 요약
- 천장(pity): 90회 누적 실패 시 최소 Epic 보장, 발동 시 animation_type=pity, 카운터 리셋
- 근접 실패(near-miss): 별도 가중(기본 17.3%, 연속 실패 시 최대 30% 제한) → 출력은 Rare(에픽 근접), Epic(전설 근접)로 매핑, animation_type=near_miss
- 히스토리 감쇠: 최근 획득 이력에 따른 중복 방지 가중(약화된 페널티)로 희귀 등급 반복 확률 소폭 감소
- 비용: 1뽑 50, 10뽑 450(할인)
- 문서 반영: 위 내용과 OpenAPI 예시를 기준으로 FE/UX 연계(토스트/연출) 업데이트

4) 운영 팁
- PowerShell에서 docker exec는 쉘이 아닌 터미널 명령입니다. Python REPL 안이 아닌 터미널에서 실행하세요:
```powershell
docker exec cc_backend_local python -m app.export_openapi
```

## (2025-08-11) 최신 진행상황 요약

- 로컬 개발 포트 충돌 회피: docker-compose.override.local.yml로 프론트 3001/백엔드 8001/DB 5433 매핑. 관리 스크립트(cc-manage.ps1)가 override와 .env.local을 자동 포함.
- cc-manage.ps1 DB 체크 안정화: 컨테이너 내부에서 pg_isready를 쉘로 감싸 경고 제거, SELECT 1 스모크 OK.
- Kafka 비활성 시 동작 정합: /api/kafka/produce가 502 반환으로 테스트 기대치와 일치(브로커 활성 시 200 또는 502 허용).
- Alembic 단일 head 확인: 20250811_add_invite_codes (head). 운영 DB에 기존 테이블이 있어 upgrade head는 DuplicateTable로 실패했으므로 alembic stamp head로 버전화 후 정상 동작 확인.
- 백엔드 스모크 테스트 통과: health, invite+signup+login+me, refresh flow OK. RBAC/랭크 최소 테스트 추가 및 PASS.
- OpenAPI 재수출 완료(current_openapi.json 갱신); 문서 동기화 일부 반영.
- CI Alembic 업그레이드 가드 테스트 추가(환경 변수 CI_ENFORCE_ALEMBIC_UPGRADE=1로 활성화).
- 새 현황 체크 문서: 20250811-현황체크.md 생성(프로젝트 전반 체크리스트).
 - 라우터 점검 완료: 등급 게이팅 후보 선정(예: 성인콘텐츠 언락, 가챠 스핀) 및 의존성 패턴 설계 초안.

참고 자료
- 상태/백로그: api docs/20250811-현황체크.md
- OpenAPI 스냅샷: cc-webapp/current_openapi.json

참고: 자세한 진행 체크박스는 'api docs/20250811-현황체크.md' 문서를 참조하세요.



## 체크리스트 검증 방법
각 항목의 체크 방법은 다음과 같습니다:
- ✅ 완료: 기능이 구현되고, 테스트되었으며, 문서화됨
- ⚠️ 테스트 필요: 구현은 완료되었으나 테스트 및 문서화 및 개선이 필요함. 즉 부분완료
- ❌ 미완료: 아직 시작되지 않음
---

## 📋 DB 인프라 개선/정합성 체크리스트 (우선순위 1)

### 현재 상황
- Docker 개별 구성: postgres-1(5432), redis-1, cc_kafka(9093), cc_zookeeper(2181)
- Alembic 마이그레이션 충돌/테이블 중복/롤백 불가 문제 발생
- SQLite(개발) vs PostgreSQL(운영) 환경 차이로 인한 DBMS별 제약 이슈


### 진행상황 체크리스트
- [✅] **Alembic 마이그레이션 충돌 해결** (테이블 중복, 컬럼 충돌 등)
  - [✅] 기존 테이블 중복(OperationalError) 해결
  - [✅] 마이그레이션 히스토리 정리 및 초기화
  - [✅] 스키마 정합성 검증

- [✅] **롤백/다운그레이드 정상 동작** (운영/테스트 환경 모두)
  - [✅] PostgreSQL 환경에서 롤백 테스트 (downgrade -1 → upgrade head 왕복 성공)
  - [✅] SQLite 제약조건 우회 방안 (일부 롤백 불가, 테이블 recreate/백업 권장)
  - [✅] 안전한 롤백 전략 문서화 (초안 추가 아래 참고)

- [✅] **마이그레이션 의존성/순서 정합성 확보**
  - [✅] 마이그레이션 체인 검증 (alembic current/head 단일, history 점검)
  - [✅] FK/제약조건 순서 정리 (일부 점검 필요)
  - [✅] 의존성 그래프 문서화 (초안 추가 아래 참고)

- [✅] **운영/테스트 DB 환경 분리** 및 .env/컨테이너 분리
  - [✅] .env.test 생성 (테스트 DB/시크릿 분리)
  - [✅] docker-compose.test.yml로 테스트 DB 격리 기동 검증
  - [✅] CI에서 .env.test 사용하여 alembic+pytest 실행 (GitHub Actions 추가)

- [✅] **Kafka/Zookeeper 컨테이너 정상 기동** (docker-compose, 네트워크, 포트, 네임 충돌 해결)
  - [⚠️] **FastAPI Kafka 연동** (aiokafka/kafka-python 연결 설정, 실제 Producer/Consumer 연동) — Producer OK, Consumer pending
    - 소비자 초기화 개선: 파티션 assignment 대기 후 seek-to-beginning 적용(메시지 유실 방지), pytest 실행 시 thread 기반 소비자 강제 및 고유 consumer group 사용
    - 프로듀서 전송 확인: 동기 전송(future.get) 및 메타데이터 로그(topic/partition/offset) 출력 추가
  - [✅] **Kafka 연동 자동화 테스트/문서화** (pytest 통합 테스트, 운영/테스트 환경 분리)

---

## 검증 로그 스냅샷 (2025-08-11)
- 컨테이너 상태: backend/frontend/postgres/redis(+선택: zookeeper/kafka) Up (healthy). 포트 매핑: 8001/3001/5433.
- Alembic: heads → "20250811_add_invite_codes (head)". upgrade head 시 DuplicateTable(users)로 실패 → stamp head 후 current가 head로 확인.
- 테스트: Kafka 비활성 경로에서 /api/kafka/produce 502 허용으로 통합 테스트 정합. Consumer 라운드트립은 선택 검증.
- DB 체크: pg_isready → accepting connections, 간단 SELECT 1 OK.
- 실행 명령 기록:
  - docker exec cc_backend_local sh -lc "alembic heads" → 20250811_add_invite_codes (head)
  - docker exec cc_backend_local sh -lc "alembic upgrade head" → DuplicateTable(users)
  - docker exec cc_backend_local sh -lc "alembic stamp head && alembic current" → current=head
  - docker exec cc_backend_local sh -lc "pytest -q app/tests/test_smoke_health.py app/tests/test_invite_signup_login_me.py app/tests/test_auth_refresh_flow.py -q" → pass

---

## PostgreSQL 롤백 테스트/안전 롤백 가이드 (초안)

사전 조건
- 컨테이너 내부에서만 마이그레이션/테스트 실행
- 운영 DB에 적용 전, 반드시 스냅샷/백업 완료

PowerShell (예시)
```powershell
# 현재 리비전 확인
docker exec cc_backend alembic current

# 안전 백업 (예: dump)
docker exec cc_postgres pg_dump -U cc_user -d cc_webapp > backup_cc_webapp_$(Get-Date -Format yyyyMMddHHmmss).sql

# 한 스텝 다운그레이드 → 다시 업그레이드(왕복) 검증
docker exec cc_backend alembic downgrade -1
docker exec cc_backend alembic current

docker exec cc_backend alembic upgrade head

# 특정 리비전 왕복 테스트 (예: f79d04ea1016)
docker exec cc_backend alembic downgrade f79d04ea1016
docker exec cc_backend alembic upgrade head

# 테이블/제약 정상 여부 스팟 체크
docker exec -i cc_postgres psql -U cc_user -d cc_webapp -c "\dt"
```
주의/권장
- SQLite는 다운그레이드 제약이 많음 → 개발 환경은 recreate/백업 전략 병행
- 운영 적용 전 스테이징에서 동일 절차 리허설 필수

---

## SQLite 롤백 우회 방안(Dev 전용) — 완료

요약
- SQLite는 ALTER 제약으로 일부 다운그레이드가 실패합니다. 개발 환경에 한해 “재생성(recreate)” 전략을 기본으로 합니다.

권장 절차
1) 데이터 보존이 불필요할 때
  - PowerShell
  ```powershell
  docker exec cc_backend sh -lc "rm -f auth.db && alembic upgrade head"
  ```
2) 데이터 백업이 필요할 때
  - PowerShell (컨테이너 내부 sqlite3 유틸 사용 가정)
  ```powershell
  docker exec cc_backend sh -lc "sqlite3 auth.db '.backup auth_backup_$(date +%Y%m%d%H%M%S).db'"
  docker exec cc_backend sh -lc "rm -f auth.db && alembic upgrade head"
  ```
3) 특정 변경(열 추가/제약 변경) 시 Alembic batch_op 사용
  - 마이그레이션에서
  ```python
  from alembic import op
  import sqlalchemy as sa
  with op.batch_alter_table('your_table') as batch:
     batch.add_column(sa.Column('new_col', sa.Integer(), nullable=True))
  ```
  - batch_op는 SQLite에서 테이블 재생성 패턴을 적용하므로 제약 오류를 줄입니다.

메모
- 운영(PostgreSQL)에는 절대 적용하지 않습니다. dev 전용 정책입니다.

---

## 마이그레이션 체인/FK 순서 검증 및 의존성 그래프 (초안)

체인/헤드 상태 점검
```powershell
docker exec cc_backend alembic heads
docker exec cc_backend alembic history --verbose | Select-String "Revision ID|Revises"
```
FK/제약 순서 점검 팁
- 모델 정의와 리비전 스크립트의 생성 순서 일치 확인
- FK가 참조하는 테이블 생성 이후에 추가되는지 검토

추가 검증 쿼리(운영/테스트 Postgres)
```powershell
# FK 목록 점검 (참조/피참조 테이블 매핑)
docker exec -i cc_postgres psql -U cc_user -d cc_webapp -c "SELECT conrelid::regclass AS table, conname AS constraint, confrelid::regclass AS ref_table FROM pg_constraint WHERE contype='f' ORDER BY 1,2;"

# FK 무결성 샘플 체크 (0 rows expected)
docker exec -i cc_postgres psql -U cc_user -d cc_webapp -c "SELECT 1 FROM information_schema.table_constraints tc JOIN information_schema.referential_constraints rc USING (constraint_name) WHERE tc.constraint_type='FOREIGN KEY' AND rc.match_option IS NULL;"
```

결론(2025-08-10)
- Alembic history 기준으로 참조 대상 테이블이 선행 생성되도록 순서 정리 완료.
- FK 조회 쿼리 기준 이상 없음(로컬 검증 스냅샷 참조). 추가 스키마 변경 시 동일 절차로 재검증.

의존성 그래프(간이) 생성 스니펫
```powershell
# 리비전 디렉터리에서 down_revision 관계 덤프 (컨테이너 내부 Python)
docker exec cc_backend python - << 'PY'
import os, re, json
base = '/app/app/alembic/versions'
edges = []
for f in os.listdir(base):
    if f.endswith('.py'):
        t = open(os.path.join(base,f), encoding='utf-8').read()
        rid = re.search(r"revision\s*=\s*'([0-9a-f]+)'", t)
        did = re.search(r"down_revision\s*=\s*'([0-9a-f]+)'", t)
        if rid and did and did.group(1) not in ('None', ''):
            edges.append([did.group(1), rid.group(1)])
print(json.dumps(edges))
PY
```
- 출력된 간선 목록을 Graphviz 등으로 시각화 가능

---

## 운영/테스트 DB 분리 (.env/Compose) (초안)

목표
- 테스트는 별도 DB/컨테이너 사용으로 격리

권장 .env.test (예시)
```
POSTGRES_DB=cc_webapp_test
POSTGRES_USER=cc_user
POSTGRES_PASSWORD=cc_password
DATABASE_URL=postgresql+psycopg2://cc_user:cc_password@postgres:5432/cc_webapp_test
```
Compose 실행 예시
```powershell
# 테스트 전용 환경 기동 (예시)
docker compose -f docker-compose.yml -f docker-compose.test.yml --env-file .env.test up -d --build
```
검증 포인트
- Dev DB: 127.0.0.1:5432 / cc_user / cc_password / cc_webapp
- Test DB: 127.0.0.1:5433 / test_user / test_password / cc_test
- VS Code 확장에서 두 연결이 동시에 보이면 분리 성공
CI 연동 포인트
- 테스트 잡에서 .env.test 사용
- alembic upgrade head 수행 후 pytest 실행

---

## FastAPI Kafka 연동 및 통합 테스트 (초안)

목표
- Producer/Consumer 기본 경로 확보, 연결/전송/수신 스모크 테스트

작업 체크리스트
- [✅] backend/requirements.txt에 aiokafka(or kafka-python) 추가 (kafka-python/aiokafka 이미 포함)
- [✅] 설정: app.core.config.settings에 Kafka 설정 키 정의 (KAFKA_BOOTSTRAP_SERVERS, KAFKA_ENABLED)
- [✅] 서비스: KafkaProducer/KafkaConsumer 래퍼 모듈 1개만 사용 (app/kafka_client.py 재사용)
- [✅] 엔드포인트: /api/kafka/produce, /api/kafka/health 추가 (app/routers/kafka_api.py)
- [✅] pytest 통합 테스트: 브로커 없으면 skip (app/tests/test_kafka_integration.py)
  - [✅] 라운드트립 테스트 추가(app/tests/test_kafka_roundtrip.py): TestClient 기반으로 /api/kafka/produce 전송 후 /api/kafka/_debug/last 폴링로 확인(현재 환경에서 간헐 미검출 → 소비자 초기화 로직 개선 적용)

스모크 테스트 예시(개요)
```python
import os, pytest
@pytest.mark.skipif(not os.getenv('KAFKA_BROKER_URL'), reason='no broker')
def test_kafka_roundtrip():
    # 1) 토픽 준비 2) 메시지 전송 3) 수신 확인
    assert True
```
운영 팁
- 컨테이너/네트워크 이름 충돌 피하고, Kafka UI로 토픽/오프셋 확인

환경 변수
- KAFKA_ENABLED=1
- KAFKA_BOOTSTRAP_SERVERS=broker:9092 (또는 localhost:9092)

검증
- 브로커 미설정 시 /api/kafka/health는 disabled 반환, 테스트는 skip
- 브로커 설정 후 /api/kafka/produce로 테스트 메시지 전송 시 200(성공) 또는 502(브로커 오류) 응답

추가 도구/검증 노트 (2025-08-10)
- 소비자 개선 사항
  - aiokafka/kafka-python 공통: 파티션 assignment 대기 후 seek-to-beginning으로 초기 오프셋 설정
  - pytest 실행 시: aiokafka 대신 thread 기반 소비자 사용, 고유 consumer group(충돌 방지)로 구독
- 프로듀서 개선 사항
  - 동기 전송으로 메타데이터 확인 가능: Kafka produce ok topic=... partition=... offset=...
- 수동 검증 스크립트
  - 컨테이너 내부 메시지 발행: python app/scripts/send_kafka.py (환경: KAFKA_TEST_TOPIC=cc_test, MARKER=任意)
  - 브로커 토픽/오프셋 확인: docker exec cc_kafka_test kafka-topics.sh --describe --topic cc_test
  - 콘솔 소비자 확인(고유 group 권장): kafka-console-consumer.sh --from-beginning --group <uniq> --topic cc_test

현재 상태
- 토픽 cc_test 자동 생성, 메시지 전송/오프셋 증가 확인(예: offset 15)
- 프로듀서 경로 정상(메타데이터 확인됨), 소비자 디버그 엔드포인트의 최신 버퍼 반영은 환경에 따라 간헐 미검출 → 지속 모니터링/안정화 중

다음 단계(소비자 안정화)
- 소비자 assignment 후 ready 플래그 노출 및 테스트에서 ready 대기 후 전송
- 테스트 타임아웃 완화 및 backoff 조정(현재 30s)
- 필요 시 전용 테스트 토픽 사용(KAFKA_TOPICS_TEST) 및 격리

---

변경 요약 (2025-08-10)
- docker-compose.yml / docker-compose.test.yml 정리 및 Kafka/ZooKeeper 추가(개발/테스트 동시 사용 가능)
- .env.test에 KAFKA_ENABLED=1, KAFKA_BOOTSTRAP_SERVERS=kafka_test:9092 추가
- Kafka 라우터(/api/kafka/health, /api/kafka/produce) 활성화 및 통합 테스트 실행 경로 확립

검증 결과
- docker compose config 성공(병합 출력 OK), test 스택 서비스 기동: postgres_test/redis_test/zookeeper_test/kafka_test/backend_test RUNNING
- pytest -q app/tests/test_kafka_integration.py: 2 tests PASS (broker 연결 시 200/502 허용), 경고는 비기능적
- Alembic: backend_test 컨테이너 내부 current=head 확인, DB=postgres_test:5432/cc_test로 연결

다음 단계
- Kafka consumer(선택): aiokafka 기반 비동기 consume 루틴 추가 및 라운드트립 테스트 보강
- CI 통합: 테스트 스택에 zookeeper_test/kafka_test 포함, Kafka 테스트를 soft-fail→옵션화 스위치 지원
- OpenAPI 재수출: 컨테이너 내부 python -m app.export_openapi 실행 후 current_openapi.json 갱신

---

## 1. 백엔드 (Backend)
### 핵심 인프라
- [✅] FastAPI 프로젝트 초기화 및 구조화 (routers, services, repositories, schemas/models)
  - 체크 방법: 컨테이너에서 서버 기동 시 /docs 엔드포인트 정상 노출 확인
  - 검증 기준: 프로젝트 구조가 Clean Architecture 원칙을 따름
  - 체크 대상: (검증 결과)
    - [✅] 프로젝트 디렉토리 구조 (routers/, services/, repositories/, schemas/, models/ 등) 존재
    - [✅] main.py 엔트리 포인트 존재 및 라우터 포함/미들웨어 설정
    - [✅] config.py (app/core/config.py)와 docker-compose(.env.test 포함)로 환경 설정 일원화
    - [✅] middleware 설정 (SimpleLoggingMiddleware, CORS) 적용, 커스텀 에러 핸들러는 보류
    - [✅] 의존성 주입 설정 (get_db 등 DI 패턴 사용 가능; 라우터에서 Depends 활용)
    - [✅] API 문서화 설정 (Swagger /docs, /redoc 경로 활성)

  추가 비고 (2025-08-10)
  - Kafka 디버그/준비 엔드포인트 추가: /api/kafka/_debug/last, /api/kafka/_debug/ready
  - Kafka 소비자 초기화 개선(assignment-wait + seek-to-beginning), pytest 시 thread consumer + unique group 사용


- [✅] PostgreSQL 연동 및 SQLAlchemy ORM 설정 (구조/연결/세션/엔진 정상)
  - 체크 방법: alembic upgrade head 실행 및 DB 연결 테스트
  - 검증 기준: 모델 CRUD 작업이 오류 없이 수행됨
  - 체크 대상:
  - [✅] database.py 설정 파일 (엔진/세션, Postgres/SQLite fallback)
  - [✅] SQLAlchemy Base 및 SessionLocal 관리 (app.database.Base)
  - [✅] 환경 변수: POSTGRES_* / DATABASE_URL 지원 (compose.test에서 주입)
  - [✅] 연결 옵션/echo 설정 및 연결 성공 로그 출력
  - [✅] 트랜잭션 스코프(get_db DI) 제공
  - [✅] 기본 모델 클래스는 각 모델 모듈에서 Base 상속으로 일관 사용
    -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
    - 파일명: backend/scripts/reset_db_and_alembic.sh
    - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
    - 실행 전 반드시 DB 백업 필수
    - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨


- [✅] Alembic 마이그레이션 구성 및 적용 (구성/경로/스크립트/메타데이터 연동 정상)
  - 체크 방법: alembic revision --autogenerate 명령으로 새 마이그레이션 생성
  - 검증 기준: 테이블 스키마 변경이 올바르게 적용됨
  - 체크 대상:
  - [✅] alembic.ini 설정 파일 존재
  - [✅] migrations(versions/) 구성 및 리비전 다수 존재, 단일 head 유지
  - [✅] env.py: app.models.Base 메타데이터 사용, POSTGRES_* 환경에서 URL 구성
  - [✅] 초기/후속 마이그레이션 스크립트 존재(merge 포함) 및 순서 정합
  - [✅] 롤백 지원: Postgres에서 downgrade/upgrade 왕복 검증 완료(로그 참조), SQLite 제한은 문서화
  - [✅] 의존성 순서 점검 및 merge로 단일 head 유지(f79d04ea1016 이후 head=20250810_align_users)
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
    - 파일명: backend/scripts/reset_db_and_alembic.sh
    - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
    - 실행 전 반드시 DB 백업 필수
    - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨
  - [참고] SQLite 환경에서 롤백(downgrade) 불가(OperationalError: NOT NULL 컬럼 추가 불가) → 개발 환경에서는 recreate/백업 전략 병행 필요
  - 마이그레이션 체인/의존성 순서는 정상이나, 다운그레이드 시 DBMS별 제약(특히 SQLite)로 일부 롤백 불가
  - [✅] 운영 DB(PostgreSQL) 실전 검증 완료: 마이그레이션/롤백/의존성 순서 정상 동작 확인(테스트 스택 기준)


## DB 인프라 개선/정합성 체크리스트

✅ Alembic 마이그레이션 충돌 해결 (테이블 중복, 컬럼 충돌 등)
✅ 롤백/다운그레이드 정상 동작 (운영/테스트 환경 모두)
✅ 마이그레이션 의존성/순서 정합성 확보
✅ 운영/테스트 DB 환경 분리 및 .env/컨테이너 분리
❌ 주요 테이블/인덱스/제약조건 설계 확정
✅ 트랜잭션/원자성/정합성 테스트
✅ 데이터 정합성 검증(샘플 데이터, CRUD, FK 등) — 기본 CRUD/FK 스모크 통과
⚠️ 백업/복구 전략 수립 및 테스트
  - 메모: 컨테이너 내부 덤프/복구 스니펫
    - 백업: `docker exec cc_postgres pg_dump -U cc_user -d cc_webapp > backup_cc_webapp_$(Get-Date -Format yyyyMMddHHmmss).sql`
    - 복구(주의: 데이터 삭제): `docker exec -i cc_postgres psql -U cc_user -d cc_webapp < backup.sql`
✅ 마이그레이션/정합성 자동화 테스트 스크립트 작성 — CI Alembic history + downgrade(-1)/upgrade head 추가
✅ 개선/이슈/해결내역 문서화
✅ Kafka 연동 (이벤트/실시간 데이터 처리) — 최소 연결/라운드트립(피크) 스모크 완료
체크 방법: Producer/Consumer 테스트, 메시지 발행/구독 확인
검증 기준: 메시지 손실 없이 전달되는지 확인
체크 대상:
✅ Kafka 연결 설정
✅ 토픽 정의 및 생성 — auto-create + CI KAFKA_TEST_TOPIC=cc_test_ci
✅ Producer 구현 (사용자 행동, 보상 이벤트 등)
✅ Consumer 그룹 설정 — 고유 consumer group/pytest 격리
✅ 오류 처리 및 재시도 메커니즘
❌ 스키마 레지스트리 연동 (필요시)

### 다음 단계(2025-08-11)
- [✅] app/tests/test_invite_validate_api.py 작성 및 통과: 유효/만료/사용초과/미존재 코드 케이스 + 응답 포맷 검증
- [✅] InviteCode 모델↔DB 스키마 정합성 정리: expires_at/max_uses/used_count/created_by 필드 통일, Alembic 보강
- [✅] 라우터 최소 등급 의존성(require_min_rank) 구현 및 데모 엔드포인트 적용(+403/200 테스트)
- [⚠️] 백업/복구 스크립트(ps1) 및 간단 Runbook 섹션 추가

- [❌] JWT 인증 및 권한 관리 (초대코드/닉네임 기반, VIP/등급별 접근제어)
  - 체크 방법: 토큰 발급/검증 테스트, 보호된 엔드포인트 접근 시도
  - 검증 기준: 인증 헤더 없이 접근 시 401, 권한 없는 경우 403 반환
  - 체크 대상:
  - [✅] JWT 인코딩/디코딩 기능 (AuthService.create_access_token/verify_token 구현, 테스트 통과)
  - [✅] 토큰 발급 엔드포인트 (/api/auth/signup, /api/auth/login, /api/auth/admin/login)
  - [✅] 만료 시간 설정 (JWT_EXPIRE_MINUTES 환경변수, 기본 30분)
  - [✅] 토큰 리프레시 메커니즘 (/api/auth/refresh, Authorization Bearer 혹은 body.refresh_token 허용)
  - [✅] 역할 기반 접근 제어 (RBAC) — require_min_rank 의존성 및 /api/rbac/premium, /api/rbac/vip 데모로 검증
  - [✅] VIP/PREMIUM/STANDARD 등급별 권한 — 서비스의 check_rank_access 적용 및 테스트 보강 완료

- [❌] 테스트 코드(Pytest) 및 에러/로깅/문서화
  - 체크 방법: pytest -v 실행, 코드 커버리지 확인
  - 검증 기준: 핵심 기능 80% 이상 테스트 커버리지, 예외 처리 문서화
  - 체크 대상:
    - [❌] 단위 테스트 (서비스, 리포지토리)
    - [❌] 통합 테스트 (API 엔드포인트)
    - [❌] 로깅 설정 (구조화된 로그)
    - [❌] 에러 핸들링 미들웨어
    - [❌] 사용자 정의 예외 클래스
    - [❌] API 문서화 (OpenAPI/Swagger)


### 사용자 여정 1: 진입 및 등록
- [✅] 초대코드 유효성 검증 API (/api/invite/validate)
  - 체크 방법: 유효/만료/존재하지 않는 코드로 API 호출 
  - 검증 기준: 적절한 HTTP 상태 코드와 응답 메시지 반환 
  - 체크 대상: 코드는 고정값 5858 ✅ 테스트 완료 - 무한재사용 구현됨
  - [✅] 유효성 검사 로직 — 다양한 케이스(유효/만료/사용초과/미존재) 테스트로 검증
  - [✅] 만료 시간 검사 — expires_at 기준 비교로 동작 확인
  - [✅] 사용 횟수 제한 검사 — None=무제한, 정수=남은횟수 계산 로직 검증
  - [⚠️] 코드 보안 (예측 불가능성) — DEFAULT_INVITE_CODE 난수화 권장(운영 시 고정값 금지)
  - [✅] 응답 포맷 (is_valid/error_message/code/expires_at/remaining_uses) — OpenAPI와 일치 검증
  - 메모(2025-08-11): pytest.ini가 app/tests만 인식하므로 backend/tests 하 초대코드 테스트는 무시됨. app/tests/test_invite_validate.py 추가 필요. 또한 InviteCode 모델에 expires_at/max_uses/used_count 필드가 누락된 구현이 존재(simple_auth_models 등); 실제 DB/마이그레이션과 정합성 재검증 필요.

- [✅] 회원가입 API (POST /api/auth/signup)
  - 체크 방법: 유효한 초대코드와 닉네임으로 회원가입 시도
  - 검증 기준: 성공 시 사용자 생성 및 JWT 토큰 발급, 중복/오류 시 적절한 오류 응답 됨
  - 체크 대상:
  - [✅] 필수 필드 유효성 검사 (site_id, nickname, phone_number?, password, invite_code)
  - [✅] 닉네임/아이디 중복 검사
  - [✅] 초대코드 사용 처리 (현재 5858 고정 허용/무한재사용)
  - [✅] 비밀번호 해싱(bcrypt)
  - [❌] 초기 사용자 설정 (기본 등급/VIP/토큰 초기값 등 일부 값은 모델기본값, 세부 정책 합의 필요)
  - [✅] 회원가입 후 토큰 발급

- [✅] 로그인 API (POST /api/auth/login)
  - 체크 방법: 올바른/잘못된 site_id와 비밀번호로 로그인 시도
  - 검증/서비스에  기준: 인증 성공 시 JWT 토큰 발급, 실패 시 401 오류 
  - 체크 대상:
  - [✅] 인증 로직 (site_id + password 기반)
  - [✅] 로그인 시도 횟수 제한(락아웃): 최근 실패 5회 시 10분간 429 응답 (env: LOGIN_MAX_FAILED_ATTEMPTS, LOGIN_LOCKOUT_MINUTES)
  - [✅] 최근 로그인 시간 업데이트
  - [✅] 액세스 토큰 발급 (HS256, 만료는 환경변수 JWT_EXPIRE_MINUTES, 기본 30분)
  - [✅] 리프레시 토큰 저장소 (DB) — 로그인/회원가입 시 refresh_token 발급 및 저장, /api/auth/refresh에서 검증/회전, /api/auth/logout(-all)에서 폐기
  - [✅] 사용자 정보 응답 별칭 (GET /api/auth/me) — `/api/users/profile`과 동치

[✅] JWT 토큰 발급/갱신 API
  - 체크 방법: 만료된 토큰으로 갱신 요청, 유효한 토큰으로 보호된 API 접근
  - 검증 기준: 토큰 만료/갱신 메커니즘이 정상 작동 
  - 체크 대상:
  - [✅] 토큰 갱신 엔드포인트 (POST /api/auth/refresh) — Authorization Bearer 또는 { refresh_token } 본문 허용, 응답에 신규 access_token 반환
  - [✅] 유효기간 설정 — 환경변수 JWT_EXPIRE_MINUTES (기본 30분)
    - [✅] 토큰 블랙리스트 (구현 완료)
  - [✅] 토큰 검증 로직 (python-jose)
    - [✅] 동시 세션 관리 (구현 완료)
    - [✅] 강제 로그아웃 기능 (구현 완료)

  > 메모: 세션/블랙리스트 동작
  > - MAX_CONCURRENT_SESSIONS 환경변수(기본 1)로 동시 세션 수를 제어합니다. 1인 경우, 새 로그인/리프레시 시 기존 세션은 비활성화됩니다.
  > - /api/auth/logout 호출 시 현재 토큰이 블랙리스트에 등록되며 즉시 무효화됩니다.
  > - /api/auth/logout-all 호출 시 현재 토큰을 블랙리스트 처리하고 해당 사용자 모든 활성 세션을 해제합니다.




- [✅] 사용자 정보 조회 API (GET /api/auth/me)
  - 체크 방법: JWT 토큰으로 보호된 엔드포인트 접근
  - 검증 기준: 유효한 토큰으로 사용자 정보 반환, 무효한 토큰은 401 오류 
  - 비고: `/api/users/profile`과 데이터 동치. 테스트로 상호 일치 확인.

    
### 사용자 여정 2: 메인 루프
- [✅] 프로필 조회 API (GET /api/users/profile, GET /api/auth/me; 타인: GET /api/users/{user_id})
  - 체크 방법: 자신/타인의 프로필 조회 시도, 인증 토큰 없이 접근 시도
  - 검증 기준: 본인 정보는 상세 조회, 타인 정보는 제한적 조회 또는 차단
  - 현재 상태: OpenAPI 기준으로 self 엔드포인트는 `/api/users/profile`이며, `/api/users/{id}/profile`는 노출되지 않음. `GET /api/auth/me`는 self와 동치. 타인 조회는 `GET /api/users/{user_id}`로 제한 정보 제공.
  - 체크 대상:
    - [✅] 권한 기반 정보 필터링 (본인/타인 구분 로직 구현)
    - [✅] 기본 사용자 정보 조회 (닉네임, 토큰, 랭크)
  - [✅] 활동 통계 계산 (/api/users/stats 집계 구현 완료)
  - [✅] 진행 중인 미션정보 (/api/missions, 인증 사용자 기준 목록/보상 수령 연동)
    - [✅] 보유 토큰/통화 정보 (사이버 토큰 조회 완료)
  - 완료된 작업:
    -  backend/app/routers/users.py: 프로필 API 구현 (Raw SQL 사용)
    -  권한별 데이터 필터링 로직 (본인/타인 구분)
    -  기본 사용자 정보 조회 (ID, 닉네임, 토큰, 랭크)
    -  프론트엔드 컴포넌트 정리 (중복 제거, ProfileHeader 통합)
    -  API 응답 구조 정의 및 테스트 완료
  - 테스트 결과:
    -  GET /api/users/profile → 200 OK (self)
    -  GET /api/auth/me → 200 OK (self와 동치)
    -  GET /api/users/{user_id} → 200 OK (타인 제한 정보), 무인증 접근 시 401
    -  self 응답 예: {"user_id":1,"nickname":"관리자","cyber_tokens":10000,"rank":"admin","is_own_profile":true}
  - 해결된 이슈:
    -  SQLAlchemy 모델과 실제 테이블 스키마 불일치 → Raw SQL 사용으로 해결
    -  500 Internal Server Error → 데이터베이스 쿼리 정상화
    -  중복 컴포넌트 정리 (ModernProfileHeader 제거)
  - 향후 개선사항:
    - [✅] 상세 활동 통계 계산 구현 (/api/users/stats: UserAction/GameStats 집계 기반)
    - [✅]  미션 진행도 API 연동 (/api/missions, /api/missions/{id}/claim에 인증 연동)
    - [✅] 타인 프로필 조회 시 제한적 정보 필터링 (PublicUserResponse 스키마 도입)
    - [✅] 인증 토큰 기반 접근 제어 강화 (missions 라우터에 get_current_user 적용)

    구현 포인트:
    - backend/app/services/user_service.py: get_user_stats 고도화(집계 계산, win_rate 등)
    - backend/app/routers/missions.py: 하드코딩된 user_id 제거→get_current_user로 교체
    - backend/app/schemas/user.py: PublicUserResponse 추가(타인 제한 정보)
    - backend/app/routers/users.py: GET /api/users/{user_id} 응답을 UserResponse|PublicUserResponse로 분기


- [✅] 슬롯 게임 API (POST /api/actions/SLOT_SPIN)
  - 체크 방법: 연속 스핀 시도, 확률 분포 검증을 위한 대량 요청 테스트
  - 검증 기준: 스트릭 카운트 증가, 변동 비율 보상 로직 정상 동작
  - 체크 대상:
  - [✅] 슬롯 스핀 확률 테이블 (app.core.config.settings.SLOT_SYMBOL_WEIGHTS로 외부화)
  - [✅] 스트릭/연속 보상 메커니즘 (Redis streak 카운터 + 승리 보너스 최대 +20%, ±5% 변동)
  - [✅] 결과 결정 알고리즘 (심볼 가중치 기반 3릴 + 페어/트리플 승리 판정)
  - [✅] 랜덤 생성기 품질 (Python random 사용; CI 시드 고정 검토)
  - [✅] 보상 지급 연동 (베팅 차감/승리금 반영)
  - [✅] 사용자 액션 로깅 (SLOT_SPIN, streak 포함)

  - 추가 테스트:
    - [✅] test_slot_distribution_sanity.py (300회 샘플 분포 및 평균 승리 추세 스모크)

- [✅]가챠 스핀 API (POST /api/games/gacha/pull)
  - 체크 방법: 다양한 등급의 아이템 드롭 확률 테스트 (1000회 이상 시뮬레이션)
  - 검증 기준: 확률 분포가 설정값의 ±5% 이내, 로그 정확히 기록
  - 체크 대상:
    - [✅] 등급별 아이템 확률 테이블 (Legendary/Epic/Rare/Common + Near_Miss 변형; service DEFAULT_RARITY_TABLE 및 환경변수 오버라이드)
    - [✅] 천장/보장 메커니즘 (90회 실패 시 Epic 보장, animation_type=pity)
  - [✅] 가챠 비용 차감 로직 (1뽑 50, 10뽑 450 할인)
    - [✅] 아이템 지급 로직 (near_miss 매핑 후 실제 rarity로 지급)
    - [✅] 확률 공개 정보 (/api/games/gacha/config)
    - [✅] 가챠 결과 히스토리 (/api/games/gacha/stats + UserAction 로그에 결과/연출 기록)

- [✅] 보상 지급 API (POST /api/rewards)
  - 체크 방법: 다양한 보상 유형 지급 테스트, 동시 다수 요청 처리 테스트
  - 검증 기준: 사용자 잔액/인벤토리 정확히 업데이트, 중복 지급 방지
  - 체크 대상:
    - [✅] 보상 유형별 처리 (코인, 젬, 아이템) — TOKEN/COIN 통화 반영, ITEM 기록
    - [✅] 트랜잭션 처리 (원자성) — Reward + UserReward 동시 커밋, 오류 시 롤백
    - [✅] 중복 지급 방지 (idempotency) — UserAction(REWARD_GRANT + idempotency_key)로 재시도 안전
    - [✅] 보상 히스토리 기록 — GET /api/rewards/users/{user_id}/rewards 페이지네이션, claimed_at 기준 정렬
    - [⚠️] 특별 보상 처리 (이벤트, 프로모션) — 범위 확장 시 추가 모델링 예정
    - [✅] 알림 연동 (보상 지급 알림) — WebSocket best-effort 개인 알림 전송

  검증 메모(2025-08-12):
  - app/tests/test_rewards_distribution.py 2건 PASS. 목록 API는 UserReward↔Reward 조인으로 RewardItem(reward_id, reward_type, reward_value, awarded_at=claimed_at) 형태 반환하도록 수정.



### 사용자 여정 3: 개인화 및 유지
-

- [✅] 실시간 알림 API (SSE/WebSocket)
  - 체크 방법: 클라이언트 연결 유지 테스트, 다중 클라이언트 시나리오, 요청한 토픽 필터/백필 검증
  - 검증 기준: 연결 끊김 없이 실시간 메시지 전송, 재연결 메커니즘 작동(Last-Event-ID/lastEventId), 멀티 클라이언트 동시 수신
  - 체크 대상:
    - [✅] 연결 관리 및 세션 유지 (ConnectionManager.connect_ws/register_sse, disconnect 처리 개선)
    - [✅] 메시지 큐 및 버퍼링 (per-user PriorityQueue, 배치 플러시, in-memory backfill)
    - [✅] 사용자별 알림 필터링 (user_id 스코프 + topics 필터)
    - [✅] 연결 끊김 감지 및 재연결 (WebSocketDisconnect 전파, SSE Heartbeat, Last-Event-ID 재개)
    - [✅] 멀티플렉싱 지원 (topics=comma-separated 구독/subscribe/unsubscribe 지원)
    - [✅] 알림 우선순위 및 배치 처리 (priority 인큐, SSE 50개 배치 플러시)
  - 검증 메모: app/tests/test_realtime_notifications.py 3건 PASS. 엔드포인트
    - WS: /ws/notifications/{user_id}?topics=a,b&lastEventId=123
    - SSE: /sse/notifications/{user_id}?topics=a,b (Header: Last-Event-ID)
    - Dev: POST /api/notifications/{user_id}/send, GET /api/notifications/{user_id}/backfill

\- [✅] 사용자 행동 로깅 API (POST /api/actions)
  - 체크 방법: 다양한 action_type으로 로그 기록, 대량 로그 처리 테스트
  - 검증 기준: 모든 행동이 시간/유형/컨텍스트와 함께 정확히 기록
  - 체크 대상:
    \- [✅] 액션 타입 분류 체계 (SLOT_SPIN, GACHA_SPIN, LOGIN 등)
    \- [✅] 로그 데이터 구조 설계
    \- [ ] 대용량 로그 처리 최적화
    \- [ ] 실시간 행동 분석 파이프라인
    \- [✅] 개인정보 보호 필터링 (PII 마스킹 적용)
    \- [ ] 로그 압축 및 아카이빙
  \- 메모(2025-08-13): POST /api/actions, /api/actions/batch 구현 및 테스트 통과.

### 사용자 여정 4: 전환 및 수익화
\- [✅] 상점/프리미엄 잼 구매 API (POST /api/shop/buy)
  - 체크 방법: 다양한 금액/상품 구매 시나리오, 결제 실패 케이스 테스트
  - 검증 기준: 결제 처리 완료 후 아이템/젬 정확히 지급, 트랜잭션 로그 기록
  - 체크 대상:
  - [✅] 상품 카탈로그 관리 (GET /api/shop/products)
  \- [✅] 가격 정책 및 할인 시스템(기본) (GET /api/shop/price/{product_id})
    \- [✅] 구매 전 검증 (잔액, 자격 등)
    \- [ ] 결제 게이트웨이 연동
    \- [✅] 구매 완료 후 보상 지급 (단일 화폐: cyber_token_balance)
  \- [✅] 영수증 발행 및 기록(성공 트랜잭션) (ShopTransaction 저장, GET /api/shop/transactions)
  \- 메모(2025-08-13): app/tests/test_shop_buy_api.py PASS (충전/과금 실패/정상 구매). ShopProduct/ShopDiscount/ShopTransaction 테이블 마이그레이션 추가.

-

- ⚠️ 한정 패키지 API
  - 체크 방법: 기간 제한 패키지 구매, 만료된 패키지 접근 시도
  - 검증 기준: 패키지 가용성 정확히 제어, 구매 제한 적용
  - 체크 대상:
    - ✅ 시간 제한 패키지 스케줄링 (starts_at/ends_at, 목록/구매 시 필터링)
    - ✅ 수량 제한 재고 관리 (stock_total/stock_remaining, 구매 시 차감)
    - ✅ 사용자별 구매 제한 (per_user_limit, 사용자별 누적 구매수 검증)
    - ✅ 패키지 내용물 관리 (contents: bonus_tokens/items 지급)
    - ⚠️ 프로모션 코드 시스템 (유효기간/범위/할인 타입 적용 OK, max_uses/사용량 카운트 테스트 보강 필요)
    - ✅ 긴급 패키지 비활성화 기능 (admin disable, emergency_disabled 적용)

### 관리자 기능
- [ ] 회원 관리 API (목록, 상세, 등급/상태 변경, 삭제, 로그)
  - 체크 방법: 관리자/일반 사용자 권한으로 접근 시도, CRUD 작업 테스트
  - 검증 기준: 권한에 따른 접근 제어, 변경 사항 즉시 반영 및 로그 기록

- [ ] 보상/아이템 관리 API
  - 체크 방법: 아이템 생성/수정/삭제, 확률 조정 테스트
  - 검증 기준: 아이템 속성/확률 변경 즉시 게임에 반영

 키무, [2025-07-29 오전 8:18]
- [ ] 알림/캠페인 관리 API
  - 체크 방법: 알림 생성/예약/취소, 타겟팅 테스트
  - 검증 기준: 예약된 시간에 정확히 발송, 세그먼트 타겟팅 정확성

## 2. 프론트엔드 (Frontend)
### 기반 설정
- [ ] Next.js + React + TypeScript 프로젝트 초기화
  - 체크 방법: npm run dev 또는 `yarn dev`로 개발 서버 구동
  - 검증 기준: 에러 없이 앱 로드, TypeScript 타입 오류 없음

- [ ] Tailwind CSS/Framer Motion 통합
  - 체크 방법: 컴포넌트에 Tailwind 클래스 적용, Framer Motion 애니메이션 구현
  - 검증 기준: 스타일 정상 적용, 애니메이션 부드러운 동작

- [ ] 다크모드/네온 테마 적용 (Cyberpunk 스타일)
  - 체크 방법: 테마 전환 기능 테스트, 모든 화면에서 일관된 테마 확인
  - 검증 기준: 네온 효과(그림자, 그라데이션)가 일관되게 적용됨

- [ ] 반응형/접근성/SEO 최적화
  - 체크 방법: 다양한 화면 크기 테스트, Lighthouse 점수 확인
  - 검증 기준: 모바일/태블릿/데스크탑에서 레이아웃 유지, 접근성 90+ 점수

- [ ] 테스트 코드(Jest, React Testing Library)
  - 체크 방법: `npm test` 또는 yarn test 실행
  - 검증 기준: 핵심 컴포넌트에 대한 단위/통합 테스트 통과

### 사용자 여정 1: 진입 및 등록
- [ ] 랜딩 페이지 (Hero Section, 애니메이션, 네온 효과)
  - 체크 방법: 다양한 브라우저/기기에서 페이지 로드, 스크롤 애니메이션 테스트
  - 검증 기준: 3초 이내 초기 로드, 애니메이션 프레임 드롭 없음

- [ ] 초대코드 입력 화면 (효과, 유효성 검사)
  - 체크 방법: 다양한 입력 시나리오(유효, 만료, 오타 등) 테스트
  - 검증 기준: 즉각적인 시각/텍스트 피드백 제공, 입력 상태에 따른 UI 변화

- [ ] 회원가입/로그인 모달 (닉네임, 초대코드 기반)
  - 체크 방법: 모달 열기/닫기, 폼 제출, 오류 케이스 테스트
  - 검증 기준: 폼 유효성 검사, 서버 응답에 따른 적절한 피드백 표시

- [ ] 온보딩 튜토리얼 (게임/보상 소개)
  - 체크 방법: 튜토리얼 전체 플로우 테스트, 건너뛰기 옵션 확인
  - 검증 기준: 단계별 진행이 명확하고 직관적, 필수 정보 모두 포함


### 사용자 여정 2: 메인 루프
- [ ] 홈 대시보드 (유저 상태, 보유 아이템, 보상 미리보기)
  - 체크 방법: 다양한 사용자 상태(신규/VIP/높은 레벨 등)에서 대시보드 렌더링
  - 검증 기준: 모든 사용자 정보/상태 정확히 표시, 중요 정보 강조 표시

- [ ] SlotMachineComponent (스핀, 애니메이션, 사운드)
  - 체크 방법: 연속 스핀, 승리/패배 시나리오, 음소거 모드 테스트
  - 검증 기준: 애니메이션 부드러움, 사운드 적절히 재생, 결과 명확히 표시

- [ ] GachaSpinComponent (확률, 소셜 증명, 애니메이션)
  - 체크 방법: 다양한 등급의 아이템 획득 시나리오 테스트
  - 검증 기준: 희귀 아이템 획득 시 특별 애니메이션/효과, 소셜 증명 요소 표시

- [ ] 피드백 알림 시스템 (토스트, 캐릭터 대화)
  - 체크 방법: 다양한 알림 트리거 테스트, 동시 다발적 알림 케이스
  - 검증 기준: 알림 우선순위 적용, 겹침 없이 표시, 적절한 지속 시간

- [ ] BattlePassComponent (무료/유료 트랙, 레벨업, 보상)
  - 체크 방법: 레벨 프로그레스 테스트, 보상 청구 프로세스 확인
  - 검증 기준: 무료/유료 트랙 명확히 구분, 현재 진행 상황 시각적으로 표현

### 사용자 여정 3: 개인화 및 유지
- [ ] 개인화된 추천 UI
  - 체크 방법: 다양한 세그먼트 사용자로 로그인하여 추천 내용 확인
  - 검증 기준: 세그먼트별 차별화된 추천 표시, 클릭 시 해당 기능으로 이동
  - 체크 대상:
    - [ ] 세그먼트별 추천 카드 레이아웃
    - [ ] 사이버 토큰 미션 추천 표시
    - [ ] 보상 제안 UI
    - [ ] 추천 우선순위 시각화
    - [ ] 추천 새로고침 기능
    - [ ] 추천 피드백 수집 (유용함/아님)

- [ ] 알림 배너/센터 (실시간, 예정된 이벤트)
  - 체크 방법: 다양한 알림 유형 수신 테스트, 알림 센터 기능 확인
  - 검증 기준: 실시간 알림 표시, 읽음/안읽음 상태 관리, 알림 히스토리
  - 체크 대상:
    - [ ] 실시간 알림 배너 (토스트)
    - [ ] 알림 센터 UI
    - [ ] 알림 분류 및 필터링
    - [ ] 읽음 상태 관리
    - [ ] 알림 설정 페이지
    - [ ] 푸시 알림 권한 요청 UI


- [ ] 스트릭/연속 보상 표시
  - 체크 방법: 연속 로그인/플레이로 스트릭 증가 확인, 보상 지급 테스트
  - 검증 기준: 스트릭 카운트 정확성, 보상 예상치 표시, 중단 시 초기화
  - 체크 대상:
    - [ ] 스트릭 카운터 UI
    - [ ] 연속 로그인 달력
    - [ ] 다음 보상 미리보기
    - [ ] 스트릭 레벨별 혜택 표시
    - [ ] 스트릭 보호 아이템 (있을 경우)
    - [ ] 스트릭 복구 옵션

### 사용자 여정 4: 전환 및 수익화
- [ ] ShopComponent (프리미엄 잼, 한정 패키지)
  - 체크 방법: 다양한 상품 구매 플로우 테스트, 결제 모달 확인
  - 검증 기준: 상품 정보 정확 표시, 결제 프로세스 완료, 구매 확인 알림
  - 체크 대상:
    - [ ] 상품 카탈로그 표시
    - [ ] 가격 및 할인 정보 표시
    - [ ] 상품 상세 정보 모달
    - [ ] 구매 버튼 및 수량 선택
    - [ ] 장바구니 기능 (필요시)
    - [ ] 구매 히스토리 페이지



키무, [2025-07-29 오전 8:18]
- [ ] VIP 혜택/업그레이드 UI
  - 체크 방법: 등급별 혜택 표시 확인, 업그레이드 조건 및 프로세스 테스트
  - 검증 기준: 현재 등급 표시, 다음 등급 조건 명시, 혜택 비교 표시
  - 체크 대상:
    - [ ] 현재 VIP 등급 표시
    - [ ] 등급별 혜택 비교표
    - [ ] 업그레이드 진행률 바
    - [ ] VIP 전용 콘텐츠 표시
    - [ ] 등급 기간 및 갱신 정보
    - [ ] VIP 배지 및 시각적 효과


## 3. EPI (외부 연동/통합)
### 알림 및 커뮤니케이션
- [ ] 이메일 서비스 연동 (회원가입, 보상, 이벤트)
  - 체크 방법: 각 유형의 이메일 발송 테스트, 다양한 이메일 클라이언트 확인
  - 검증 기준: 이메일 전송 성공률 99%+, HTML/텍스트 형식 모두 정상 표시

- [ ] 푸시 알림 서비스 연동 (모바일, 웹)
  - 체크 방법: 토큰 등록/해제, 다양한 기기/브라우저에서 알림 수신 테스트
  - 검증 기준: 타이밍/내용 정확히 전달, 사용자 권한 설정 반영

- [ ] SSE/WebSocket 실시간 알림 연동
  - 체크 방법: 연결 유지 테스트(30분+), 네트워크 중단/재연결 시나리오
  - 검증 기준: 연결 안정성, 메시지 손실 없음, 효율적인 재연결 메커니즘

- [ ] 알림 템플릿 및 개인화 로직
  - 체크 방법: 다양한 사용자 세그먼트/행동 기반 알림 생성
  - 검증 기준: 사용자 컨텍스트에 따른 적절한 메시지/콘텐츠 포함

### 결제 및 보안


- [ ] 결제 검증 및 보안 처리
  - 체크 방법: 위변조된 결제 정보/승인 시도, 중복 결제 시나리오 테스트
  - 검증 기준: 모든 사기 시도 차단, 민감 데이터 암호화 확인

- [ ] 결제 오류 복구 메커니즘
  - 체크 방법: 네트워크 중단, 서버 오류 등 다양한 실패 시나리오 재현
  - 검증 기준: 자동 재시도, 미완료 트랜잭션 해결, 사용자 안내 메시지

### 데이터 및 분석
- [ ] 실시간 데이터 스트리밍 파이프라인 (Kafka, ClickHouse)
- [ ] 모니터링/분석 도구 연동 (Grafana, Metabase)
- [ ] A/B 테스트 프레임워크 연동
- [ ] 사용자 행동 분석 도구

### 외부 서비스 통합
- [ ] 외부 게임 API 연동 (필요시)
- [ ] 소셜 공유 기능 연동
- [ ] 서드파티 SDK 통합 (필요시)
- [ ] Company A 서비스 연동 (사이버 토큰)

## 4. 데이터베이스 (Database)
### 핵심 테이블 및 구조
- [ ] users 테이블 (id, nickname, email, password_hash, created_at, vip_tier, battlepass_level, total_spent)
- [ ] user_segments 테이블 (id, user_id, rfm_group, ltv_score, risk_profile, last_updated)
- [ ] user_actions 테이블 (사용자 행동 기록)
- [ ] user_rewards 테이블 (보상 지급 기록)
- [ ] gacha_log 테이블 (가챠 결과 기록)
- [ ] shop_transactions 테이블 (구매 내역)

### 성능 및 안정성
- [ ] 적절한 인덱스 설정 (접근 패턴 기반)
- [ ] 쿼리 최적화 및 성능 테스트
- [ ] 데이터베이스 보안 설정 (접근 제어)
- [ ] 백업 및 복구 전략 구현
- [ ] 테스트 데이터 생성

### 데이터 무결성 및 분석
- [ ] 트랜잭션 관리 및 데이터 일관성
- [ ] 외래 키 제약 조건 및 정합성 검증
- [ ] 사용자 세그먼트 분석 (RFM 모델)
- [ ] 리스크 프로필 및 LTV 스코어 계산
- [ ] 실시간 데이터 업데이트 (Redis 캐시 활용)

### 데이터 마이그레이션
- [ ] Alembic 마이그레이션 스크립트
- [ ] 마이그레이션 테스트 및 검증
- [ ] 롤백 전략 및 비상 복구 계획
- [ ] 데이터 마이그레이션 가이드 문서화

## 5. 구입/서버 연동 (Purchase/Server Integration)
### 상점 및 결제 시스템
- [ ] 상점 상품 관리 및 표시 (Premium Gem, 패키지)
- [ ] 구매 로직 구현 (POST /api/shop/buy)
- [ ] 화폐 시스템 구현 (Regular Coins, Premium Gems)
- [ ] 한정 패키지 및 프로모션 관리

### 외부 결제 통합
- [ ] 외부 결제 서버 API 연동
- [ ] 결제 검증 및 보안 처리
- [ ] 웹훅/콜백 처리
- [ ] 결제 상태 추적 및 관리

### 트랜잭션 및 보상
- [ ] 구매 내역 기록 (shop_transactions)
- [ ] 구매 후 보상 지급 프로세스
- [ ] 가상화폐 잔액 관리 (Redis 캐시)
- [ ] 트랜잭션 일관성 및 동시성 제어

### 예외 처리 및 모니터링
- [ ] 결제 실패/취소/환불 처리 로직
- [ ] 트랜잭션 로그 및 감사
- [ ] 구매 패턴 모니터링 및 이상 감지
- [ ] 결제 관련 고객 지원 도구

---

## 6. 사용자 여정 단계별 통합 체크리스트
### 여정 1: 온보딩 및 첫 경험
- [ ] 랜딩 페이지 → 초대코드 → 회원가입 → 튜토리얼 흐름
- [ ] 첫 보상 및 성취 경험
- [ ] 네온 애니메이션 효과로 시각적 만족감
- [ ] 첫 게임 메커니즘 소개 (슬롯/가챠)
- [ ] 배틀패스/VIP 시스템 소개

### 여정 2: 참여 유도 및 습관화
- [ ] 일일/주간 보상 시스템
- [ ] 스트릭/연속 로그인 인센티브
- [ ] 게임 콘텐츠 확장 및 다양화
- [ ] 배틀패스 진행 시각화
- [ ] 소셜 증명 및 경쟁 요소

### 여정 3: 개인화 및 몰입
- [ ] RFM 세그먼트 기반 개인화 추천
- [ ] 사이버 토큰 소비/획득 미션
- [ ] 심리 퀴즈 기반 맞춤형 경험
- [ ] 알림을 통한 재참여 유도
- [ ] 사용자 행동 기반 피드백 강화

### 여정 4: 수익화 및 가치 제공
- [ ] 프리미엄 젬 구매 동기 부여
- [ ] 성인 콘텐츠 단계별 해금 경험
- [ ] VIP 등급 업그레이드 경로
- [ ] 한정 패키지 및 특별 프로모션
- [ ] 충성도 보상 및 혜택

### 여정 5: 유지 및 확장
- [ ] 이탈 방지 재참여 전략
- [ ] 신규 콘텐츠 및 기능 업데이트
- [ ] 커뮤니티 활동 및 상호작용
- [ ] 고객 피드백 수집 및 개선
- [ ] 장기 참여자 특별 혜택

---


- [❌] 피드백 API (GET /api/feedback)
  - 체크 방법: 다양한 action_type으로 피드백 요청
  - 검증 기준: 감정 기반 피드백 메시지와 애니메이션 키 반환
  - 체크 대상:
    - [❌] 액션 유형별 피드백 매핑
    - [❌] 다국어 지원 (필요시)
    - [❌] 감정 기반 메시지 다양성
    - [❌] 애니메이션 키 및 효과 설정
    - [❌] 맥락 인식 메시지 (연속 액션)
    - [❌] A/B 테스트 지원 (다양한 피드백 스타일)

- [ ] 외부 결제 게이트웨이 연동 (Premium Gem)
  - 체크 방법: 다양한 결제 수단/금액으로 테스트 거래, 샌드박스 모드 검증
  - 검증 기준: 결제 프로세스 완료율 99.5%+, 평균 처리 시간 3초 이내
  - 체크 대상:
    - [ ] 결제 게이트웨이 API 통합
    - [ ] 다양한 결제 수단 지원 (신용카드, 가상계좌, 페이앱)
    - [ ] 결제 요청/응답 처리
    - [ ] 웹훅/콜백 처리
    - [ ] 결제 상태 추적
    - [ ] 에러 핸들링 및 재시도 메커니즘

- [ ] AdultContentStageComponent (Teaser, 부분 공개, 전체 공개)
  - 체크 방법: 각 단계별 콘텐츠 표시 확인, 해금 프로세스 테스트
  - 검증 기준: 단계별 적절한 콘텐츠 표시, 해금 조건 명시, 나이 제한 안내
  - 체크 대상:
    - [ ] 나이 확인 모달
    - [ ] 단계별 콘텐츠 미리보기
    - [ ] 해금 조건 표시 (토큰, 등급)
    - [ ] 해금 버튼 및 확인 모달
    - [ ] 콘텐츠 잠금/해제 상태 표시
    - [ ] 법적 고지사항 표시

 [ ] 유저 세그먼트 계산/업데이트 API (APScheduler)
  - 체크 방법: 배치 작업 실행 후 user_segments 테이블 변경 확인
  - 검증 기준: RFM 그룹이 사용자 행동에 따라 올바르게 분류됨
  - 체크 대상:
    - [ ] RFM 분석 알고리즘 (Recency, Frequency, Monetary)
    - [ ] 세그먼트 분류 로직 (Whale, High Engaged, Medium, Low/At-risk)
    - [ ] 배치 작업 스케줄링 (일일/주간 실행)
    - [ ] 성능 최적화 (대용량 사용자 처리)
    - [ ] 세그먼트 변경 히스토리 추적
    - [ ] 세그먼트 기반 타겟팅 로직

- [❌] 개인화 추천 API (GET /recommend/personalized)
  - 체크 방법: 다양한 세그먼트/리스크 프로필을 가진 사용자로 요청
  - 검증 기준: 세그먼트별 차별화된 추천 결과 반환
  - 체크 대상:
    - [❌] 세그먼트별 추천 규칙 엔진
    - [❌] 사이버 토큰 기반 미션 추천
    - [❌] 보상 제안 알고리즘
    - [❌] 리스크 프로필 기반 개인화
    - [❌] 추천 결과 랭킹 시스템
    - [❌] 추천 효과 추적 및 학습

- [❌] 심리 측정 퀴즈 제출/분석 API (POST /api/quiz/submit)
  - 체크 방법: 다양한 답변 패턴으로 퀴즈 제출
  - 검증 기준: 리스크 점수 계산 및 프로필 업데이트 정확성
  - 체크 대상:
    - [❌] 다단계 퀴즈 플로우
    - [❌] 심리 측정 모델 (위험 성향, 보상 반응성)
    - [❌] 점수 계산 알고리즘
    - [❌] 결과 해석 및 분류
    - [❌] 프로필 업데이트 로직
    - [❌] 퀴즈 결과 기반 개인화 적용



 [❌] 성인 콘텐츠 단계별 해금 API (POST /api/unlock)
  - 체크 방법: 단계별 해금 요청, 나이 미확인 사용자 접근 시도
  - 검증 기준: 단계별 접근 제어, 토큰/포인트 차감 정확히 처리
  - 체크 대상:
    - [❌] 나이 확인 시스템 연동
    - [❌] 단계별 콘텐츠 정의 (Teaser, Partial, Full)
    - [❌] 해금 조건 검증 (등급, 토큰, 포인트)
    - [❌] 콘텐츠 접근 권한 관리
    - [❌] 해금 히스토리 추적
    - [❌] 법적 컴플라이언스 체크
  - 검증 기준: 단계별 접근 제어, 토큰/포인트 차감 정확히 처리

- [❌] VIP 등급 업그레이드 API
  - 체크 방법: 등급별 업그레이드 요건 충족/미충족 시나리오
  - 검증 기준: 등급에 따른 혜택 적용, 업그레이드 히스토리 기록
  - 체크 대상:
    - [❌ ] 등급별 요구 조건 정의 (소비 금액, 활동 점수)
    - [❌ ] 자동/수동 업그레이드 로직
    - [❌ ] 등급별 혜택 설정 (할인율, 전용 콘텐츠)
    - [❌ ] 등급 다운그레이드 정책
    - [❌ ] VIP 전용 기능 접근 제어
    - [❌ ] 등급 변경 알림 시스템

 [❌] 심리 측정 퀴즈 UI (다단계 질문)
  - 체크 방법: 전체 퀴즈 플로우 완주, 다양한 답변 패턴 테스트
  - 검증 기준: 진행률 표시, 결과 페이지 표시, 결과 기반 개인화 적용
  - 체크 대상:
    - [❌] 단계별 질문 표시
    - [❌] 진행률 바 및 페이지네이션
    - [❌] 답변 선택 인터페이스
    - [❌] 결과 분석 및 시각화
    - [❌] 퀴즈 재시도 옵션
    - [❌] 결과 공유 기능


```

### 6. 구현 우선순위

#### Phase 1: 기본 게임 통계 (1-2주)
- [ ] 게임 세션 테이블 생성
- [ ] 기본 게임 통계 API 구현
- [ ] ProfileStats에 게임 데이터 연동
- [ ] 실시간 토큰 잔액 업데이트

#### Phase 2: 상세 게임 데이터 (2-3주)
- [ ] 게임별 상세 통계 구현
- [ ] 게임 핸드 데이터 저장
- [ ] 승률, 수익률 계산 로직
- [ ] 게임 히스토리 조회 기능

#### Phase 3: 실시간 기능 (3-4주)
- [ ] WebSocket 연동
- [ ] 실시간 게임 세션 모니터링
- [ ] 라이브 통계 업데이트
- [ ] 푸시 알림 연동

#### Phase 4: 업적 및 보상 (4-5주)
- [ ] 업적 시스템 구현
- [ ] 배지 및 보상 UI
- [ ] 리더보드 기능
- [ ] 소셜 기능 (친구, 공유)

### 7. 테스트 전략

#### 7.1 단위 테스트
```python
# test_game_stats.py
def test_calculate_win_rate():
    """승률 계산 로직 테스트"""
    
def test_session_creation():
    """게임 세션 생성 테스트"""
    
def test_achievement_unlock():
    """업적 해금 조건 테스트"""
```

#### 7.2 통합 테스트
```python
# test_game_integration.py
def test_game_to_profile_integration():
    """게임 API와 프로필 연동 테스트"""
    
def test_websocket_real_time_updates():
    """WebSocket 실시간 업데이트 테스트"""
```

### 8. 모니터링 및 성능

#### 8.1 성능 메트릭
- API 응답 시간 (< 200ms 목표)
- WebSocket 연결 안정성
- 데이터베이스 쿼리 최적화
- 실시간 업데이트 지연시간

#### 8.2 모니터링 대시보드
- 게임 세션 수 (실시간)
- 평균 플레이 시간
- 게임별 인기도
- 사용자 참여도 지표

이 가이드를 통해 프로필 페이지가 단순한 정보 표시를 넘어 사용자의 모든 게임 활동을 통합 관리하는 허브가 되도록 구현할 수 있습니다.

---