사용자 중심 전역 플로우로 즉시 축 이동하겠습니다. 먼저 핵심 요구를 체크하고 단계별 실행 계획을 잡았습니다. 아래는 현재 새 우선순위와 바로 다음 액션 제안입니다.

요구 재정리 (전역 코어 플로우)

가입 / 인증 / 로그인 (온보딩)
메인 화면 (대시보드: 잔액, 진행중 이벤트, 오늘 보상)
이벤트 보상 받기 (reward claim)
이벤트 참여 (participate / progress)
게임하기 (게임 세션 시작/종료 기록)
프로필 확인 (레벨, 통계, 최근 활동)
상점에서 물건 구매 (일반 상점 + 재화 차감)
전역 데이터 서버 확장 (Kafka → ClickHouse / 분석 파이프 표준화)
프론트 전역 상태 (Auth + Profile + Events + Shop + Game state) 공유 구조
추가 고려

중복/불필요 사이드 기능(한정 패키지) → 유지하되 ‘코어 루프’ 밖으로 격리
이벤트/보상: 멱등(중복 수령 금지), 기간/조건 체크, 게임 플레이 연동
관측: Kafka 토픽 표준명 + 이벤트 스키마(고정 필드 + 확장 메타)
우선 착수 순서 (Fast Track) A. 현재 코드베이스에서 코어 라우트/스키마 존재 여부 스캔 → Gap 리스트
B. 이벤트 시스템 최소 스키마 & API 계약 초안 (participate, claim)
C. 전역 대시보드 응답 설계 (/api/dashboard) → 서버 집계 캐시 전략 포함
D. 프론트 전역 상태 모델(Store 구조) 설계 (auth + profile + dashboard + events + shop)
E. Kafka 이벤트 표준 Envelope 정의(event_type, user_id, ts, payload, trace_id)
F. 단계별 릴리즈 로드맵 문서화

다음 바로 진행할 작업 제안

(13) 전역 플로우 우선순위 재정의: 간단 메모 완성 (이미 개요 작성됨 → 완료 처리 가능)
(14) 백엔드 라우터 실제 목록 grep 해서 핵심 경로 존재/누락 확인
(15) 이벤트 시스템 설계 초안 파일 생성 (schema + API 계약)
(16) 프론트 전역 상태 다이어그램 (텍스트 구조로) 작성
(17) 데이터 파이프/Kafka 토픽 설계 문서
(18)(19) 로드맵 & 리스크 문서
확인 요청 (선택 하나 답변):

지금 바로 라우터 스캔 + Gap 분석부터 해라
이벤트 시스템 설계 초안 먼저 작성
대시보드(/api/dashboard) 통합 응답 계약부터
프론트 전역 상태(Store) 구조부터
숫자만 줘도 진행하겠습니다. 필요하면 “ALL”이라면 순서대로 빠르게 문서/파일 추가하며 진행할게요.



-----

전역 코어 사용자 여정(최소 성공 경로 MSC - Minimum Success Cycle)

가입(Signup) → 2) 로그인/JWT발급(Auth) → 3) 메인 대시보드 진입(Dashboard) → 4) 이벤트 목록 확인(Events List) → 5) 이벤트 참여(Participate) → 6) 게임 플레이 시작/종료(Game Session) → 7) 이벤트 조건 충족 후 보상 수령(Reward Claim) → 8) 프로필/진행도 확인(Profile) → 9) 상점 구매(Shop Purchase) → 대시보드 갱신(Loop Reinforcement)
각 단계 핵심 객체/데이터

User: id, site_id, nickname, tier, currencies (soft_currency, premium_currency), progression (level, exp, streak)
Event: id, type(daily/limited/progression), start_end_at, rules(condition JSON), reward_bundle
EventParticipation: user_id, event_id, progress (counters), status(active/claimable/claimed)
GameSession: session_id, user_id, game_type, started_at, ended_at, metrics(score, duration)
RewardGrant (idempotent): grant_id, user_id, source(event/game/manual), payload(json), granted_at
Purchase: purchase_id, user_id, sku_id, price, currency_type, granted_bundle, status(succeeded/failed)
Dashboard Aggregate(캐시): user snapshot + active events summary + pending rewards count
API (목표 통합 경로 제안) Auth:

POST /api/auth/signup
POST /api/auth/login
GET /api/auth/me
Dashboard:

GET /api/dashboard (원샷: profile + currencies + active_events + pending_rewards + recent_sessions(3) + shop_highlights)
Events:

GET /api/events (필터: active=true)
POST /api/events/{event_id}/participate
POST /api/events/{event_id}/progress (게임/행동 트리거 서버 내부에서 호출하거나 클라이언트 제한된 호출)
POST /api/events/{event_id}/claim
Game:

POST /api/game/sessions/start (body: game_type)
POST /api/game/sessions/{id}/end (score,duration,meta)
GET /api/game/sessions/recent?limit=10
Rewards (직접 조회/감사):

GET /api/rewards/pending
GET /api/rewards/history?limit=50
Shop:

GET /api/shop/catalog (정규 상품; 한정 패키지 별도 segmenting)
POST /api/shop/purchase (sku_id, quantity=1)
Profile:

GET /api/profile (상세: 누적 score / top_scores / 최근 이벤트 참여 상태 포함)
이벤트 상태머신 (간단) inactive -> active -> (progress < target) staying active -> claimable (조건 달성) -> claimed (종결)
만료 시: active|claimable -> expired (claim 불가)
멱등성: claim 시 reward_grant (unique grant_key=user_id+event_id) UPSERT

Kafka 이벤트 Envelope (표준) { "event_type": "user.signup" | "event.participate" | "event.progress" | "event.claim" | "game.session.start" | "game.session.end" | "shop.purchase.succeeded", "user_id": <int|null>, "ts": <iso8601>, "trace_id": <uuid>, "payload": { domain-specific }, "version": 1 }

ClickHouse 적재 (예시 테이블) CREATE TABLE events_log ( event_date Date, ts DateTime, event_type String, user_id UInt32, trace_id String, payload_json String ) ENGINE = MergeTree PARTITION BY toYYYYMM(event_date) ORDER BY (event_type, ts);

프론트 전역 상태(Store 슬라이스)

auth: { token, user, loading }
dashboard: { profile, currencies, eventsSummary, pendingRewardsCount, shopHighlights, lastFetched }
events: { list[], participationsById, claiming, errors }
game: { currentSession {id, game_type, started_at}, recent[], status }
shop: { catalog[], purchasingSku, purchaseResult }
rewards: { pending[], history[], loading }
ui: { toasts[], modal, networkBusy }
캐시/성능 전략

/api/dashboard 1초 내 재요청 시 ETag 혹은 If-None-Match 활용 (서버측 hash)
이벤트 진행(progress)은 서버 내부 (게임 세션 종료 Hook) 로 증가 -> 클라이언트 progress POST 최소화
reward claim 후 dashboard invalidate
즉시 후속 (다음 할 일 제안)

(14) 실제 코드 라우터 스캔하여 위 제안 대비 누락/중복 표 생성
(15) 이벤트 스키마 & Alembic 마이그레이션 초안 (events, event_participation, reward_grant)
(18) 단계별 릴리즈(Phase A: Dashboard read-only → B: Events participate → C: Game sessions → D: Reward claim/shop 통합)


-----

핵심 플로우 대비 현재 구현 vs 격차

Auth/Signup/Login: 이미 auth 라우터 존재 (세부 점검 후 토큰 회전/refresh 정책 명시 필요).
Dashboard: 세분화된 /api/dashboard/main|games|social-proof 만 존재 → 통합 /api/dashboard (핵심 KPIs + 진행 중 이벤트/미션 + 보상 요약) 신규 필요.
Events: /api/events/* (목록, 상세, join, progress, claim) 존재. 참여 중복 방지용 (user_id,event_id) 유니크 제약 없음 → 추가 권장. progress JSON 업데이트에 last_progress_at 없어서 레이스 타임스탬프 추가 권장.
Missions: /api/events/missions/* 세트 존재. daily/weekly reset 동작은 reset_at 컬럼(UserMission) 활용 가능. 진행/클레임 로직 idempotency 키 없음 → (user_id, mission_id, claimed) 유니크 + claim 시 user_rewards.idempotency_key 사용 권장.
Game Sessions: /api/games/session/start|end|active 구현. 이벤트/미션 자동 진행 반영 훅(진행량 증가 + Kafka publish) 미구현 → start/end/round 처리 후 mission/event progress service 호출 & kafka 이벤트 추가 필요.
Rewards: /api/rewards/distribute 중앙 분배 있음. 상점/한정패키지 구매는 별도 Reward + UserReward 직접 생성 → RewardService(distribute_reward) 호출로 통합 + idempotency_key = shop_tx.charge_id 또는 purchase:{tx_id}. 분배 이벤트 Kafka 존재(Rewards topic) → 이벤트/미션 claim 시도 동일 포맷 전송 필요.
Shop: 구매 흐름 안정. 한정패키지 compat endpoint 유지 중 → Phase B 이후 /limited/* 폐기 또는 /deprecated 네임스페이스 이동 계획 필요.
Profile: users / users_enhanced 라우터 존재 (세부 필드 합치기 및 /api/profile 단일 조회 정리 필요).
제안 스키마/마이그레이션 추가 (최소)

event_participations: UNIQUE (user_id, event_id), 인덱스 (user_id, completed, claimed_rewards).
event_participations: last_progress_at TIMESTAMP NULL.
user_missions: UNIQUE (user_id, mission_id), 인덱스 (user_id, completed, claimed).
user_missions: last_progress_at TIMESTAMP NULL.
user_rewards: (이미 idempotency_key unique + reward_type 인덱스 존재) → OK.
game_sessions: 이미 status, external_session_id 인덱스 있음 → OK.
새 뷰/머티리얼라이즈드? 선택: dashboard_aggregate 뷰 (user_id별 최근 24h 게임수, 미션 완료/진행, 미수령 보상 카운트) 후 Phase C 고려.
상태머신 요약

EventParticipation: CREATED(join) → IN_PROGRESS(progress 업데이트) → COMPLETED(progress 기준 충족) → CLAIMED(보상 지급).
UserMission: CREATED(자동 생성 또는 조회 시 lazy 생성) → IN_PROGRESS → COMPLETED(target_value 도달) → CLAIMED → (reset 주기 시) RESET_TO_CREATED.
Reward 분배: REQUESTED → (idempotency check) GRANTED(UserReward row 생성) → (optional use) CONSUMED.
API 계약 (추가/수정)

GET /api/dashboard: { kpis: {...}, active_events:[...], missions:{daily:[...], weekly:[...], achievements:[...]}, pending_rewards:int }
POST /api/events/{id}/progress (존재) → 응답에 server_progress_version / completed 플래그 포함(레이스 방지).
POST /api/events/{id}/claim: idempotency_key 허용(헤더 X-Idempotency-Key) → UserReward.idempotency_key.
POST /api/events/missions/{id}/progress, /claim (미션 전용 progress 엔드포인트 분리 고려) → 동일한 응답 구조 표준화 {status, progress, completed, claimed, reward_grant?:RewardItem}.
POST /api/rewards/distribute: 유지. 내부적으로 RewardService; shop/events/mission은 이 경로 호출로 통합.
Kafka 이벤트 표준 (value JSON) { "event_type":"reward.granted"|"event.progress"|"game.session.start"|"game.session.end", "user_id":..., "ts": ISO8601(Z), "trace_id": uuid, "payload":{ domain specific }, "idempotency_key": optional } 추가 토픽: gameplay_events (세션 start/end), mission_events, reward_events 통합 또는 단일 enrichment 파이프라인.

마이그레이션 파일 제안

versions/20250821_add_event_mission_progress_meta.py
add unique/indexes + last_progress_at columns.
안전: if exists/has_column 체크 guard.
Phase 제안(요약, 상세는 로드맵 Task 18에서)

Phase A: Unified /api/dashboard (읽기 전용 aggregation), progress/claim response 표준 스펙 정의 (코드 최소 수정).
Phase B: RewardService 통합(Shop/Events/Missions), unique constraints + idempotency enforcement, Kafka 이벤트 표준 적용.
Phase C: 자동 mission/event progress hook in game session start/end, analytics pipeline (Kafka → sink draft).
Phase D: Deprecated endpoints 정리, performance indexes 튜닝, dashboard materialized view/ caching.
즉시 구현 우선순위 (Phase A)

새 /api/dashboard 엔드포인트 추가 (기존 3개 내부 호출 or 서비스 레이어 통합).
이벤트/미션 claim 응답 형태 표준화 (progress_version + reward_items).
마이그레이션: unique 및 last_progress_at 컬럼.
리스크/주의

Unique 제약 추가 시 기존 중복 레코드 사전 정리 필요(스캔 후 삭제 또는 하나만 유지).
JSON progress 동시 업데이트 → lost update 방지: progress_version(int) 증분 or updated_at compare; 단순히 last_progress_at로 optimistic check 가능.
Idempotency 확장 시 기존 UserReward 중복 지급 케이스 회고 필요(최근 N일 스캔).
Dashboard aggregation 성능: 최초 간단 select + count; 후속 materialized view 고려.
다음 작업 제안 (Task 16~19 준비)

Task 16: 전역 상태 다이어그램 + store keys (auth.user, dashboard.summary, events.byId, missions.daily|weekly, rewards.pendingCount, game.activeSession).
Task 17: Kafka topic spec + ClickHouse 테이블 초안 (MergeTree by (event_type, ts, user_id) partition by toYYYYMMDD(ts)).
Task 18: 상세 Phase 문서화 + 테스트 영향도(새 claims tests, dashboard aggregator test).
Task 19: 리스크 표 + 대응 전략 (unique 추가 마이그레이션 롤백, idempotency race, Kafka outage fallback(로컬 WAL)).
필요 시 마이그레이션 초안 코드 생성 가능—진행할지 지시 주시면 즉시 작성합니다


------
Task 20 (Unified dashboard) 완료.
다음: Claim 응답 표준화(이벤트/미션), 모델 컬럼 & 마이그레이션, 서비스 progress_version 로직.
다음 제안 작업 순서

모델/마이그레이션 먼저: event_participations & user_missions 에 last_progress_at, progress_version(Integer, default 0), UNIQUE(user_id,event_id)/(user_id,mission_id).
서비스 로직: update_event_progress / update_mission_progress 에 progress_version +=1 & last_progress_at 갱신.
Claim 응답 스키마 수정: reward_items 배열 + progress_version 포함, idempotency 대비 (추후 UserReward 경로 통합 시).
테스트(추가):
새 /api/dashboard 200 & 필드 존재.
이벤트 progress 호출 시 progress_version 증가.
중복 join 후 unique 제약 위반 안됨.



업 완료 요약

모델 확장: event_participations, user_missions 에 progress_version, last_progress_at 컬럼 추가 (모델 + Alembic).
제약/인덱스: UNIQUE(user_id,event_id)/(user_id,mission_id) 및 조회 최적화 인덱스 추가 마이그레이션 작성.
서비스 로직: Event/Mission progress 업데이트 시 progress_version 증가 & last_progress_at 기록.
Claim 응답: ClaimRewardResponse 확장(progress_version, reward_items) + 이벤트 claim 라우터 적용.
통합 대시보드: /api/dashboard 추가(이전 완료 상태 유지).
다음 검증 권장(컨테이너 내부 실행)

alembic upgrade head (단일 head 유지 확인).
이벤트 진행/claim 수동 호출 → progress_version 증가 & claim 응답 reward_items 배열 노출.
동일 이벤트 재-join 시 UNIQUE 위반 없는지 (이미 존재하면 기존 participation 반환).
후속 남은 Task (16~19)

프론트 전역 상태/스토어 설계
Kafka/ClickHouse 이벤트 스트림 스펙
단계별 Phase 문서화
리스크/대응 표 작성


ions taken
Created four design/spec documents:
api docs/FRONT_STATE_MAPPING_SPEC.md
api docs/DATA_PIPELINE_SPEC.md
api docs/PHASE_ROADMAP.md
api docs/RISK_REGISTER.md
Each covers Tasks 16–19: frontend state map, data pipeline (Kafka→ClickHouse), phased roadmap (A–D), and risk register.
Updated todo list: Tasks 16–19 marked completed.
highlights
Frontend spec defines slices, caching, optimistic progress rules, progress_version handling, future SSE mapping.
Data pipeline spec standardizes event envelope, topic list, ClickHouse DDL (raw + MVs), outbox, dedupe, KPIs, rollout phases.
Roadmap details exit criteria per phase and testing strategy with rollback guidance.
Risk register catalogs technical, security, operational, product risks with mitigations and near-term actions.
next steps (optional)
Implement Mission claim response alignment (Phase B item).
Draft event_outbox migration + producer wrapper.
Prepare ClickHouse DDL execution scripts and basic health query.
Let me know if you want any of these converted into tasks/issues or expanded into implementation.